// Generated by dts-bundle-generator v9.5.1

import { AllKeys, Any, Falsy, Intersect, Remap } from '@alloc/types';
import * as CSS$1 from 'csstype';
import { Color, mixColor, parseColor } from 'linear-color';
import { Key } from 'ts-key-enum';

type Disposable$1<T = {}> = T & {
	dispose(): void;
};
export declare function attachDisposer<T extends object>(object: T, dispose: () => void): Disposable$1<T>;
export declare function isDisposable<T extends {}>(arg: T): arg is Disposable$1<T>;
/**
 * Create a `Disposable` object from a function and arguments array.
 *
 * The arguments array is included in the returned object for introspection
 * purposes.
 */
export declare function createDisposable<Args extends readonly any[]>(args: Args, dispose: (...args: Args) => void, thisArg?: any): Disposable$1<{
	args: Args;
	thisArg?: any;
}>;
export declare function mergeDisposables(...objects: Disposable$1[]): Disposable$1<{
	objects: Disposable$1[];
}>;
export type Promisable<T> = T | PromiseLike<T>;
/**
 * A disposable promise for a one-time event.
 */
export declare function promiseEvent<T extends Event>(target: EventTarget, type: string): Disposable$1<Promise<T>>;
/**
 * A disposable promise for `setTimeout`.
 */
export declare function promiseTimeout(delay: number): Disposable$1<Promise<void>>;
/**
 * A disposable `Promise.race` that disposes all promises when settled.
 */
export declare function promiseRace<T>(promises: Iterable<T | PromiseLike<T>>): Disposable$1<Promise<Awaited<T>>>;
/**
 * Disposable promises are useful for async dependencies that need to be
 * disposed of when the component unmounts. For example, async data should stop
 * loading on unmount and event listeners should be removed.
 *
 * NOTE: This type is meant for arguments. For return values, use `Disposable<Promise<T>>`.
 */
export interface DisposablePromise<T> extends PromiseLike<T> {
	dispose: () => void;
}
/**
 * An "open promise" can be resolved/rejected from outside the promise and its
 * settled state can be checked (and even observed).
 */
export declare class OpenPromise<T> extends Promise<T> {
	readonly resolve: void extends T ? (value?: Promisable<T>) => void : (value: Promisable<T>) => void;
	readonly reject: (reason?: any) => void;
	get settled(): boolean;
	constructor(executor?: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void) => void);
}
declare const kRefType: unique symbol;
export type ObservableHooks = {
	/**
	 * A ref was changed and the given observer was notified.
	 */
	observe(observer: Observer, ref: ReadonlyRef<any>, newValue: any, oldValue: any): void;
	/**
	 * A ref was observed or unobserved.
	 */
	isObserved(ref: ReadonlyRef<any>, observer: Observer, isObserved: boolean): void;
	/**
	 * An update was completed or threw an error.
	 */
	didUpdate(observer: Observer | ComputedRef, error: any, result: any): void;
};
/**
 * Observable hooks are only active in the development build. They provide a way
 * for debugging tools to be notified of various useful events.
 */
export declare const setObservableHooks: (newHooks: ObservableHooks) => void;
type InternalRef<T = any> = Ref<T> & {
	_value: T;
	_observers: Set<Observer>;
	_depth: number;
	_isObserved: (observer: Observer, isObserved: boolean) => void;
};
/**
 * A read-only version of `Ref` that doesn't allow mutation (i.e. its `value`
 * property cannot be assigned to).
 *
 * This class cannot be constructed directly, but it can be useful for creating
 * your own subclass where consumers should not be able to mutate the value. You
 * may also want to use this as a return type of your custom hook that returns a
 * ref but doesn't want to expose the mutation API.
 *
 * This is a superclass of Ref, ComputedRef, and ArrayRef.
 */
export declare abstract class ReadonlyRef<T = any> {
	protected _value: T;
	readonly debugId: string | number | undefined;
	protected _observers: Set<Observer>;
	protected get _depth(): number;
	constructor(_value: T, debugId?: string | number);
	/**
	 * In addition to adding/removing an observer, computed refs use this method
	 * to switch between eager and lazy computation mode.
	 */
	protected _isObserved(observer: Observer, isObserved: boolean): void;
	get [kRefType](): string;
	get value(): T;
	peek(): T;
	/**
	 * Create a `ComputedRef` whose value is derived from `this.value` using the
	 * given function.
	 */
	computedMap<U>(compute: (value: T) => U): ComputedRef<U>;
	/**
	 * Create a `ComputedRef` that does the following:
	 *
	 * If `this.value` is truthy, use the first argument. Otherwise, use the
	 * second argument (if none is provided, return undefined). Function arguments
	 * are called within the `computed` function.
	 */
	computedIf<True>(trueValue: ComputedInput<True>): ComputedRef<True | undefined>;
	computedIf<True, False>(trueValue: ComputedInput<True>, falseValue: ComputedInput<False>): ComputedRef<True | False>;
	/**
	 * Create a `ComputedRef` that uses the first argument if `this.value` is
	 * falsy. Otherwise, undefined is used. Function arguments are called within
	 * the `computed` function.
	 */
	computedElse<False>(falseValue: ComputedInput<False>): ComputedRef<False | undefined>;
}
export declare class Ref<T = any> extends ReadonlyRef<T> {
	get [kRefType](): string;
	set(arg: T | ((value: T) => T)): T;
	/** Use the negation operator on the current value. */
	toggle(): boolean;
}
export interface Ref<T> {
	readonly 0: T;
	readonly 1: (arg: T | ((value: T) => T)) => T;
	set value(newValue: T);
}
export declare class ArrayRef<T> extends ReadonlyRef<readonly T[]> {
	protected _arrayObservers: Set<InternalArrayObserver> | null;
	protected _produceOperation: ArrayOperation.Producer;
}
export interface ArrayRef<T> extends ArrayMutators<T>, ArrayIterators<T>, Iterable<T> {
	[index: number]: T;
	length: number;
	set value(newValue: readonly T[]);
	/**
	 * Observe a single index in the array. Any time the array is mutated, this
	 * will check the given `index` to see if a new value exists there.
	 */
	observe(index: number): ComputedRef<T>;
}
interface ArrayMutators<T> extends Pick<Array<T>, "copyWithin" | "fill" | "pop" | "push" | "reverse" | "shift" | "sort" | "splice" | "unshift"> {
}
interface ArrayIterators<T> extends Pick<Array<T>, "at" | "concat" | "entries" | "every" | "filter" | "find" | "findIndex" | "flat" | "flatMap" | "forEach" | "includes" | "indexOf" | "join" | "keys" | "lastIndexOf" | "map" | "reduce" | "reduceRight" | "slice" | "some" | "values"> {
}
/**
 * Create an observable array.
 *
 * Note: The array is cloned before each mutation.
 */
export declare let arrayRef: <T>(init?: readonly T[] | undefined, debugId?: string | number) => ArrayRef<T>;
export declare class RefMap<K, V> {
	protected _map: Map<K, Ref<V>>;
	protected _sizeRef: Ref<number>;
	protected _keysRef: ArrayRef<K>;
	constructor(entries?: Iterable<[
		K,
		V
	]>);
	get size(): number;
	get(key: K): V | undefined;
	peek(key: K): V | undefined;
	peekSize(): number;
	set(key: K, newValue: V): void;
	delete(key: K): void;
	clear(): void;
	forEach(callback: (value: V, key: K, map: RefMap<K, V>) => void): void;
	[Symbol.iterator](): Iterator<[
		K,
		V
	]>;
}
export declare namespace Observer {
	type WillUpdateFn = (ref: ReadonlyRef<any>, newValue: any, oldValue: any) => void;
	type OnUpdateFn = (result: any) => any;
}
export declare class Observer {
	readonly id: number;
	refs: Set<InternalRef<any>>;
	depth: number;
	constructor();
	protected _access(ref: InternalRef<any>, oldRefs: Set<InternalRef<any>>): any;
	protected _update(sync: boolean, oldRefs: Set<InternalRef<any>>): any;
	/**
	 * Run the `compute` function synchronously, observing any accessed refs. If
	 * no `compute` function is provided, the last used `compute` function will be
	 * reused.
	 *
	 * When those refs change, the `compute` function will run again in the next
	 * microtask (unless you call this method before then).
	 */
	update<T>(compute?: (oldRefs: Set<InternalRef<any>>) => T): T;
	/** Called when a ref has a new value. */
	observe(ref: ReadonlyRef<any>, newValue: any, oldValue: any): void;
	scheduleUpdate(ref?: ReadonlyRef<any>, newValue?: any, oldValue?: any): void;
	/**
	 * Note: A disposed observer can still be reused.
	 */
	dispose(): void;
	/**
	 * Returns a bound `dispose` method.
	 */
	get destructor(): () => void;
}
export interface Observer {
	/**
	 * When true, this observer will run *after* all other observers in the queue.
	 * This is useful to ensure all side effects have been applied before this
	 * observer runs.
	 */
	isObservablyPure(): boolean;
	/**
	 * The next time this observer is updated, this method will be used to compute
	 * a new value or possibly trigger a side effect.
	 */
	nextCompute(oldRefs: Set<InternalRef<any>>): any;
	/**
	 * Called whenever an observed ref is changed.
	 */
	didObserve(ref: ReadonlyRef<any>, newValue: any, oldValue: any): void;
	/**
	 * Called when the observer has been queued to run.
	 */
	willUpdate(ref: ReadonlyRef<any>, newValue: any, oldValue: any): void;
	/**
	 * Called with the result of the `compute` function. You must either return it
	 * or return a new result.
	 */
	onUpdate(result: any): any;
}
export declare namespace ArrayOperation {
	/**
	 * A value has been added at the index.
	 */
	type Add<T = any> = {
		type: "add";
		index: number;
		count: number;
		newArray: readonly T[];
	};
	/**
	 * One or more values have been removed at the index.
	 */
	type Remove<T = any> = {
		type: "remove";
		index: number;
		count: number;
		oldArray: readonly T[];
	};
	/**
	 * The value at the index has been replaced.
	 */
	type Replace<T = any> = {
		type: "replace";
		index: number;
		newValue: T;
	};
	/**
	 * The array has been sorted or replaced entirely.
	 */
	type Rebase<T = any> = {
		type: "rebase";
		newArray: readonly T[];
		oldArray: readonly T[];
	};
	/**
	 * A function that is called with the fine-grained changes to the array.
	 */
	type Handler<T = any> = (operations: ArrayOperation<T>[], arrayRef: ArrayRef<T>) => void;
	/**
	 * An "operation producer" is called by the `ArrayRef` to produce the
	 * `ArrayOperation` set for a given mutation.
	 */
	type Producer = (method: string, args: any[], oldArray: any[], newArray: any[]) => ArrayOperation | ArrayOperation[] | false;
}
/**
 * An observed change to an `ArrayRef` for fine-grained reactivity.
 */
export type ArrayOperation<T = any> = ArrayOperation.Add<T> | ArrayOperation.Remove<T> | ArrayOperation.Replace<T> | ArrayOperation.Rebase<T>;
/**
 * While a normal observer can only observe an `ArrayRef` as a whole, an array
 * observer can observe the fine-grained changes to the array (specified by the
 * `ArrayOperation` type).
 *
 * Prefer using `observeArrayOperations` to create an array observer, instead of
 * constructing one manually.
 */
export declare class ArrayObserver<T> extends Observer {
	readonly target: ArrayRef<T>;
	protected compute: ArrayOperation.Handler<T>;
	protected operations: ArrayOperation<T>[];
	constructor(target: ArrayRef<T>, compute: ArrayOperation.Handler<T>);
	protected onOperation(operation: ArrayOperation<T> | ArrayOperation<T>[]): void;
	nextCompute(): void;
	dispose(): void;
	/**
	 * When an `ArrayRef` is observed by an `ArrayObserver` (not to be confused
	 * with a normal `Observer`), the `ArrayRef` will call this `produceOperation`
	 * static method to produce the `ArrayOperation` set for a given mutation.
	 */
	static produceOperation: ArrayOperation.Producer;
}
type InternalArrayObserver<T = any> = ArrayObserver<T> & {
	onOperation(operation: ArrayOperation<T>): void;
};
export declare class ComputedRef<T = any> extends ReadonlyRef<T> {
	protected compute: () => T;
	protected _observer: Observer | null;
	protected get _depth(): number;
	constructor(compute: () => T, debugId?: string | number);
	protected _isObserved(observer: Observer, isObserved: boolean): void;
	get [kRefType](): string;
	get value(): T;
	/**
	 * Get the current value without observing it. If the ref is empty, the
	 * `compute` function will run immediately.
	 */
	peek(): T;
	/**
	 * Clear the current value. If the ref is observed, the `compute` function
	 * will run again in the next microtask.
	 */
	clear(): void;
	private static Observer;
}
export interface ComputedRef<T> {
	readonly 0: T;
}
/**
 * Run a function and collect all refs that were accessed.
 */
export declare function collectAccessedRefs<T>(fn: () => T, accessedRefs: Set<Ref>): T;
/**
 * Create a `Ref` object with an optional initial value.
 *
 * Its `value` property is observable. Its `peek` method lets you access the
 * current value without risk of being observed. There are also convenience
 * methods for creating "computeds" with less boilerplate; their method names
 * all start with `computed` (i.e. `computedIf`, `computedMap`, etc).
 */
export declare const ref: {
	<T>(value: T, debugId?: string | number): Ref<T>;
	<T>(value?: T, debugId?: string | number): Ref<T | undefined>;
};
/**
 * Create a `RefMap` object, optionally providing a set of initial entries.
 *
 * "Ref maps" are similar to `Map` objects, but accessing and iterating a
 * `RefMap` can be observed. Its `size` property can also be observed.
 */
export declare const refMap: <K, V>(entries?: Iterable<[
	K,
	V
]> | undefined) => RefMap<K, V>;
export declare const computed: <T>(compute: () => T, debugId?: string | number) => ComputedRef<T>;
/** Observe any refs accessed in the compute function. */
export declare function observe(compute: () => void): Observer;
/** Observe a single ref. */
export declare function observe<T>(ref: ReadonlyRef<T>, compute: (newValue: T, oldValue: T, ref: ReadonlyRef<T>) => void): Observer;
/**
 * Observe fine-grained changes to an `ArrayRef`. Note that your handler isn't
 * called immediately. It receives a batch of changes in the next microtask.
 *
 * The returned `ArrayObserver` must be manually disposed when no longer needed,
 * or it will continue receiving changes until the associated `ArrayRef` is
 * garbage collected.
 */
export declare const observeArrayOperations: <T>(arrayRef: ArrayRef<T>, handler: ArrayOperation.Handler<T>) => ArrayObserver<T>;
export declare function isReadonlyRef(value: any): boolean;
export declare function isRef<T = any>(value: any): value is ReadonlyRef<T>;
/**
 * Like `ref.peek()` but applies to all access within the given `compute`
 * callback.
 */
export declare function peek<T, Args extends any[]>(compute: (...args: Args) => T, ...args: Args): T;
/**
 * Like `ref.peek()` but for computed properties or custom properties (i.e.
 * defined with `Object.defineProperty`).
 */
export declare function peek<T extends object, K extends keyof T>(object: T, key: K): T[K];
/**
 * Coerce a possibly reactive value to a raw value.
 */
export declare const unref: <T>(arg: T | ReadonlyRef<T>) => T;
/**
 * For values used as inputs to `computed` wrappers.
 */
export type ComputedInput<T> = T | ReadonlyRef<T> | (() => T | ReadonlyRef<T>);
/**
 * Similar to `unref` but also supports thunk values.
 *
 * Most useful inside `computed` callbacks.
 */
export declare const evaluateInput: <T>(arg: ComputedInput<T>) => T;
/**
 * Observe the given `Ref` until it has a truthy value, then run the effect and
 * return the result. If the ref is already truthy, the effect is run
 * immediately.
 */
export declare function when<T, Result>(condition: ReadonlyRef<T>): Disposable$1<Promise<Exclude<T, Falsy>>>;
export declare function when<T, Result = Exclude<T, Falsy>>(condition: ReadonlyRef<T>, effect: (value: Exclude<T, Falsy>) => Promisable<Result>): Disposable$1<Promise<Result>>;
/**
 * A "flat" ref is one that cannot point to another ref.
 */
export type FlatReadonlyRef<T> = ReadonlyRef<Unref<T>>;
/**
 * Exclude ref types from type `T`.
 */
export type Unref<T> = Exclude<T, ReadonlyRef>;
/**
 * Takes the value of a component prop that contains JSX children of any kind
 * and returns a {@link ChildrenFragment} with children materialized as  DOM
 * nodes. Since JSX elements passed as children or “element props” are not
 * always materialized by default, this hook is useful when you need a reference
 * to actual DOM nodes.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useChildren(element: JSX.ElementProp, deps?: readonly any[]): ChildrenFragment;
export declare function useChildren(elements: JSX.ElementsProp, deps?: readonly any[]): ChildrenFragment;
export declare function useChildren(children: JSX.ChildrenProp, deps?: readonly any[]): ChildrenFragment;
/**
 * Returns true if the given value is the result of a `useChildren` call.
 */
export declare function isChildrenFragment(value: any): value is ChildrenFragment;
/**
 * The result of a `useChildren` call. It wraps around a `DocumentFragment` and
 * provides convenience methods for working with the child nodes. It can be
 * passed as a child of a JSX element or returned from a component.
 */
export interface ChildrenFragment {
	get fragment(): DocumentFragment;
	get firstChild(): Comment;
	get firstElementChild(): JSX.Element | null;
	get lastChild(): ChildNode;
	get lastElementChild(): JSX.Element | null;
	/**
	 * The returned array is not live, so it won't update if the fragment changes.
	 */
	get childNodes(): ChildNode[];
	/**
	 * The returned array is not live, so it won't update if the fragment changes.
	 */
	toElements(): JSX.Element[];
	/**
	 * Throw an error if the fragment is not a single element, otherwise return
	 * the single element.
	 */
	expectSingleElement(): JSX.Element;
	/**
	 * Return the single element in the fragment, or `null` if there are no
	 * elements. Throw an error if there are multiple elements.
	 */
	expectSingleElementOrNull(): JSX.Element | null;
	/**
	 * Call the given callback for each element in the fragment, with the element
	 * and its index as arguments.
	 */
	forEachElement<This = typeof globalThis>(callback: (this: This, element: JSX.Element, index: number) => void, context?: This): void;
}
declare const kAlienNodeType: unique symbol;
declare const kShadowRootNodeType = 99;
declare const kDeferredNodeType = 98;
declare const kTemplateNodeType = 96;
export type Context<T = any> = {
	(props: {
		value: T;
		children: JSX.ChildrenProp;
	}): JSX.Element;
	with(value: T): [
		Context<T>,
		Ref<T>
	];
};
export type ForwardedContext = {
	(props: {
		children: JSX.ChildrenProp;
	}): JSX.Element;
	forward<Args extends any[], Result>(fn: (...args: Args) => Result, ...args: Args): Result;
};
export declare class ContextStore extends Map<Context, Ref> {
	get Provider(): ForwardedContext;
	get: <T>(key: Context<T>) => Ref<T> | undefined;
	set: <T>(key: Context<T>, value: Ref<T>) => this;
}
export declare function defineContext(context: ContextStore): ForwardedContext;
export declare function defineContext<T>(initial: T): Context<T>;
export declare function defineContext<T>(): Context<T | undefined>;
interface ContextMap extends Map<Context, Ref> {
	get<T>(key: Context<T>): Ref<T> | undefined;
	set<T>(key: Context<T>, value: Ref<T>): this;
}
type ResolvedChild = ChildNode | AlienNode | null;
export interface AriaAttributes {
	/** Identifies the currently active element when DOM focus is on a composite widget, textbox, group, or application. */
	"aria-activedescendant"?: string | undefined;
	/** Indicates whether assistive technologies will present all, or only parts of, the changed region based on the change notifications defined by the aria-relevant attribute. */
	"aria-atomic"?: Booleanish | undefined;
	/**
	 * Indicates whether inputting text could trigger display of one or more predictions of the user's intended value for an input and specifies how predictions would be
	 * presented if they are made.
	 */
	"aria-autocomplete"?: "none" | "inline" | "list" | "both" | undefined;
	/** Indicates an element is being modified and that assistive technologies MAY want to wait until the modifications are complete before exposing them to the user. */
	"aria-busy"?: Booleanish | undefined;
	/**
	 * Indicates the current "checked" state of checkboxes, radio buttons, and other widgets.
	 * @see aria-pressed @see aria-selected.
	 */
	"aria-checked"?: boolean | "false" | "mixed" | "true" | undefined;
	/**
	 * Defines the total number of columns in a table, grid, or treegrid.
	 * @see aria-colindex.
	 */
	"aria-colcount"?: number | undefined;
	/**
	 * Defines an element's column index or position with respect to the total number of columns within a table, grid, or treegrid.
	 * @see aria-colcount @see aria-colspan.
	 */
	"aria-colindex"?: number | undefined;
	/**
	 * Defines the number of columns spanned by a cell or gridcell within a table, grid, or treegrid.
	 * @see aria-colindex @see aria-rowspan.
	 */
	"aria-colspan"?: number | undefined;
	/**
	 * Identifies the element (or elements) whose contents or presence are controlled by the current element.
	 * @see aria-owns.
	 */
	"aria-controls"?: string | undefined;
	/** Indicates the element that represents the current item within a container or set of related elements. */
	"aria-current"?: Booleanish | "page" | "step" | "location" | "date" | "time" | undefined;
	/**
	 * Identifies the element (or elements) that describes the object.
	 * @see aria-labelledby
	 */
	"aria-describedby"?: string | undefined;
	/**
	 * Identifies the element that provides a detailed, extended description for the object.
	 * @see aria-describedby.
	 */
	"aria-details"?: string | undefined;
	/**
	 * Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.
	 * @see aria-hidden @see aria-readonly.
	 */
	"aria-disabled"?: Booleanish | undefined;
	/**
	 * Indicates what functions can be performed when a dragged object is released on the drop target.
	 * @deprecated in ARIA 1.1
	 */
	"aria-dropeffect"?: "none" | "copy" | "execute" | "link" | "move" | "popup" | undefined;
	/**
	 * Identifies the element that provides an error message for the object.
	 * @see aria-invalid @see aria-describedby.
	 */
	"aria-errormessage"?: string | undefined;
	/** Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed. */
	"aria-expanded"?: Booleanish | undefined;
	/**
	 * Identifies the next element (or elements) in an alternate reading order of content which, at the user's discretion,
	 * allows assistive technology to override the general default of reading in document source order.
	 */
	"aria-flowto"?: string | undefined;
	/**
	 * Indicates an element's "grabbed" state in a drag-and-drop operation.
	 * @deprecated in ARIA 1.1
	 */
	"aria-grabbed"?: Booleanish | undefined;
	/** Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element. */
	"aria-haspopup"?: Booleanish | "menu" | "listbox" | "tree" | "grid" | "dialog" | undefined;
	/**
	 * Indicates whether the element is exposed to an accessibility API.
	 * @see aria-disabled.
	 */
	"aria-hidden"?: Booleanish | undefined;
	/**
	 * Indicates the entered value does not conform to the format expected by the application.
	 * @see aria-errormessage.
	 */
	"aria-invalid"?: Booleanish | "grammar" | "spelling" | undefined;
	/** Indicates keyboard shortcuts that an author has implemented to activate or give focus to an element. */
	"aria-keyshortcuts"?: string | undefined;
	/**
	 * Defines a string value that labels the current element.
	 * @see aria-labelledby.
	 */
	"aria-label"?: string | undefined;
	/**
	 * Identifies the element (or elements) that labels the current element.
	 * @see aria-describedby.
	 */
	"aria-labelledby"?: string | undefined;
	/** Defines the hierarchical level of an element within a structure. */
	"aria-level"?: number | undefined;
	/** Indicates that an element will be updated, and describes the types of updates the user agents, assistive technologies, and user can expect from the live region. */
	"aria-live"?: "off" | "assertive" | "polite" | undefined;
	/** Indicates whether an element is modal when displayed. */
	"aria-modal"?: Booleanish | undefined;
	/** Indicates whether a text box accepts multiple lines of input or only a single line. */
	"aria-multiline"?: Booleanish | undefined;
	/** Indicates that the user may select more than one item from the current selectable descendants. */
	"aria-multiselectable"?: Booleanish | undefined;
	/** Indicates whether the element's orientation is horizontal, vertical, or unknown/ambiguous. */
	"aria-orientation"?: "horizontal" | "vertical" | undefined;
	/**
	 * Identifies an element (or elements) in order to define a visual, functional, or contextual parent/child relationship
	 * between DOM elements where the DOM hierarchy cannot be used to represent the relationship.
	 * @see aria-controls.
	 */
	"aria-owns"?: string | undefined;
	/**
	 * Defines a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value.
	 * A hint could be a sample value or a brief description of the expected format.
	 */
	"aria-placeholder"?: string | undefined;
	/**
	 * Defines an element's number or position in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.
	 * @see aria-setsize.
	 */
	"aria-posinset"?: number | undefined;
	/**
	 * Indicates the current "pressed" state of toggle buttons.
	 * @see aria-checked @see aria-selected.
	 */
	"aria-pressed"?: boolean | "false" | "mixed" | "true" | undefined;
	/**
	 * Indicates that the element is not editable, but is otherwise operable.
	 * @see aria-disabled.
	 */
	"aria-readonly"?: Booleanish | undefined;
	/**
	 * Indicates what notifications the user agent will trigger when the accessibility tree within a live region is modified.
	 * @see aria-atomic.
	 */
	"aria-relevant"?: "additions" | "additions removals" | "additions text" | "all" | "removals" | "removals additions" | "removals text" | "text" | "text additions" | "text removals" | undefined;
	/** Indicates that user input is required on the element before a form may be submitted. */
	"aria-required"?: Booleanish | undefined;
	/** Defines a human-readable, author-localized description for the role of an element. */
	"aria-roledescription"?: string | undefined;
	/**
	 * Defines the total number of rows in a table, grid, or treegrid.
	 * @see aria-rowindex.
	 */
	"aria-rowcount"?: number | undefined;
	/**
	 * Defines an element's row index or position with respect to the total number of rows within a table, grid, or treegrid.
	 * @see aria-rowcount @see aria-rowspan.
	 */
	"aria-rowindex"?: number | undefined;
	/**
	 * Defines the number of rows spanned by a cell or gridcell within a table, grid, or treegrid.
	 * @see aria-rowindex @see aria-colspan.
	 */
	"aria-rowspan"?: number | undefined;
	/**
	 * Indicates the current "selected" state of various widgets.
	 * @see aria-checked @see aria-pressed.
	 */
	"aria-selected"?: Booleanish | undefined;
	/**
	 * Defines the number of items in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.
	 * @see aria-posinset.
	 */
	"aria-setsize"?: number | undefined;
	/** Indicates if items in a table or grid are sorted in ascending or descending order. */
	"aria-sort"?: "none" | "ascending" | "descending" | "other" | undefined;
	/** Defines the maximum allowed value for a range widget. */
	"aria-valuemax"?: number | undefined;
	/** Defines the minimum allowed value for a range widget. */
	"aria-valuemin"?: number | undefined;
	/**
	 * Defines the current value for a range widget.
	 * @see aria-valuetext.
	 */
	"aria-valuenow"?: number | undefined;
	/** Defines the human readable text alternative of aria-valuenow for a range widget. */
	"aria-valuetext"?: string | undefined;
}
export type AriaRole = "alert" | "alertdialog" | "application" | "article" | "banner" | "button" | "cell" | "checkbox" | "columnheader" | "combobox" | "complementary" | "contentinfo" | "definition" | "dialog" | "directory" | "document" | "feed" | "figure" | "form" | "grid" | "gridcell" | "group" | "heading" | "img" | "link" | "list" | "listbox" | "listitem" | "log" | "main" | "marquee" | "math" | "menu" | "menubar" | "menuitem" | "menuitemcheckbox" | "menuitemradio" | "navigation" | "none" | "note" | "option" | "presentation" | "progressbar" | "radio" | "radiogroup" | "region" | "row" | "rowgroup" | "rowheader" | "scrollbar" | "search" | "searchbox" | "separator" | "slider" | "spinbutton" | "status" | "switch" | "tab" | "table" | "tablist" | "tabpanel" | "term" | "textbox" | "timer" | "toolbar" | "tooltip" | "tree" | "treegrid" | "treeitem" | (string & {});
export type FunctionComponent<Props extends object = {}> = (props: Props) => JSX.Children;
export type CSSAttributes = CSSTransformAttributes & {
	[Key in Exclude<keyof CSS$1.Properties, "scale" | "rotate">]?: CSS$1.Properties<CSSLength>[Key] | null;
};
export type CSSLength = number | string;
export type CSSAngle = number | string;
export interface CSSTransformAttributes {
	rotate?: CSSAngle | null;
	rotateX?: CSSAngle | null;
	rotateY?: CSSAngle | null;
	scale?: number | null;
	scaleX?: number | null;
	scaleY?: number | null;
	x?: CSSLength | null;
	y?: CSSLength | null;
	z?: CSSLength | null;
}
/**
 * Returns a new `AbortController` instance. When the `deps` argument changes,
 * the previous `AbortController` instance is aborted and a new one is created.
 */
export declare function useAbortController(deps: readonly any[]): AbortController;
/**
 * The `signal` argument has its `abort `event propagated to the returned
 * `AbortController` instance. When the `deps` argument changes, the
 * `AbortController` instance is aborted and a new one is created.
 */
export declare function useAbortController(signal: AbortSignal | undefined, deps: readonly any[]): AbortController;
/**
 * The `signal` argument has its `abort `event propagated to the returned
 * `AbortController` instance.
 *
 * Note: The `signal` argument is captured on first render. It won't be updated
 * unless you use a dependency array.
 */
export declare function useAbortController(signal?: AbortSignal): AbortController;
/**
 * Observe the fine-grained changes to an `ArrayRef` object.
 *
 * 🪝 This hook adds 2 to the hook offset.
 */
export declare function useArrayObserver<T>(arrayRef: ArrayRef<T> | Falsy, handler: ArrayOperation.Handler<T>): void;
export declare const useArrayRef: <T>(init?: readonly T[] | undefined, debugId?: string | number) => ArrayRef<T>;
export type ArrayViewRenderFn<T = any> = (item: T, key: JSX.ElementKey) => JSX.Children;
export declare function useArrayView<T>(array: ArrayRef<T> | Falsy, render: ArrayViewRenderFn<T>, deps?: readonly any[]): JSX.Element | null;
export type UseAsyncFn<T> = (state: UseAsync<T>) => PromiseLike<T> | T;
export declare function useAsync<T>(get: UseAsyncFn<UseAsyncAwaited<T>> | Falsy, deps: readonly any[]): UseAsync<UseAsyncAwaited<T>>;
export declare class UseAsync<T> {
	deps: readonly any[];
	private state;
	private abortCtrl;
	timestamp: number | null;
	promise: Promise<void> | null;
	effects: Disposable$1[];
	numAttempts: number;
	stale: boolean;
	constructor(deps: readonly any[]);
	/** @observable */
	get status(): "error" | "loaded" | "idle" | "loading";
	/** @observable */
	get result(): T | undefined;
	/** @observable */
	get error(): any;
	get abort(): () => void;
	get aborted(): boolean;
	get abortSignal(): AbortSignal;
	get retry(): (reset?: boolean) => void;
	markAttempt(): void;
	setPromise(promise: Promise<any>): void;
	/**
	 * Track a disposable effect that will be disposed when the component unmounts
	 * or the async getter is called again.
	 */
	get track(): {
		(effect: () => void): () => void;
		<E extends {
			dispose(): void;
		}>(effect: E): E;
	};
	protected dispose(): void;
}
/**
 * The result of a `useAsync` callback is processed such that an array
 * of promises, an array of objects with promise values, or an object
 * with promise values is awaited. If the callback's return value is a
 * promise, any resulting array or object **won't** be processed.
 */
export type UseAsyncAwaited<T> = T extends readonly (infer Item)[] ? UseAsyncAwaitedItem<Item>[] : UseAsyncAwaitedItem<T>;
type UseAsyncAwaitedItem<T> = T extends PromiseLike<infer Item> ? UseAsyncAwaited<Item> : T extends (...args: any[]) => any ? T : T extends object ? {
	[K in keyof T]: Awaited<T[K]>;
} : T;
export declare function useAutoBind<T extends object>(target: T): Readonly<T>;
export declare class ObservableBounds {
	constructor(element?: AnyElement | null);
	protected rectRef: Ref<DOMRectReadOnly | null>;
	protected resizeEffect: Disposable$1 | undefined;
	protected observedElement: AnyElement | null;
	protected observer: ResizeObserver | null;
	protected locked: boolean;
	protected topRef: ComputedRef<number> | undefined;
	protected rightRef: ComputedRef<number> | undefined;
	protected bottomRef: ComputedRef<number> | undefined;
	protected leftRef: ComputedRef<number> | undefined;
	protected widthRef: ComputedRef<number> | undefined;
	protected heightRef: ComputedRef<number> | undefined;
	get x(): number;
	get y(): number;
	get top(): number;
	get right(): number;
	get bottom(): number;
	get left(): number;
	get width(): number;
	get height(): number;
	toJSON(): any;
	observe(key: Exclude<keyof DOMRectReadOnly, "toJSON" | "x" | "y">): ComputedRef<number>;
	setElement(element: AnyElement | null): void;
	lock(flag: boolean): void;
	dispose(): void;
	protected setupResizeEffect(element: AnyElement): void;
}
export type UseBoundsOptions = {
	/** Pause the resize observer when true. */
	lock?: boolean;
	/**
	 * If you cannot or prefer not to pass a ref, you may pass an element instead.
	 */
	target?: string | HTMLElement | ReadonlyRef<HTMLElement | null> | null;
};
export declare function useBounds(options?: UseBoundsOptions): ObservableBounds;
export declare function useClickOutside(handler: () => void): {
	setElement: (element: HTMLElement | null) => void;
	enabled: boolean;
	enable: (target: HTMLElement | Document) => EffectResult;
	dispose?: (() => void) | undefined;
};
/**
 * Creates a `ComputedRef` that is updated when the dependencies change.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useComputed<T>(get: () => T, deps?: readonly any[], debugId?: string | number): ComputedRef<T> & [
	value: T
];
/**
 * Create a piece of state that persists between renders. It won't be lost when
 * the component hot reloads. The state is initialized only once, when the
 * component is mounted.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useConst<State extends object, Params extends any[]>(init: new (...params: Params) => State, ...params: Params): State;
export declare function useConst<State extends object, Params extends any[]>(init: (...params: Params) => State, ...params: Params): State;
export type Refs<T extends object> = {
	[K in string & Exclude<keyof T, "bind">]: T[K] extends readonly (infer U)[] ? ArrayRef<U> : T[K];
} & {
	bind<K extends keyof T>(key: K): Ref<T[K]>;
};
/**
 * Like `useConst` but properties are observable. Array properties are wrapped
 * with `ArrayRef` objects. Note that destructured values won't be observable.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useConstRefs<T extends object, Params extends any[]>(init: new (...params: Params) => T, ...params: Params): Refs<T>;
export declare function useConstRefs<T extends object, Params extends any[]>(init: (...params: Params) => T, ...params: Params): Refs<T>;
export declare function useConstRefs<T extends object>(init: T): Refs<T>;
/**
 * Capture the current context and return a Provider component that can
 * forward it to other components asynchronously.
 */
export declare function useContext(): ForwardedContext;
/**
 * Access the current value of the given Context type.
 */
export declare function useContext<T>(context: Context<T>): T;
/**
 * Set a timeout to run an effect after a delay, with proper cleanup on unmount.
 *
 * If no dependency array is given, the effect runs once (even if the `delay`
 * argument value is changed in a future render).
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useDelayedEffect(delay: VarArgs<number | DisposablePromise<any>>, effect: EffectCallback | Falsy, deps?: readonly any[]): void;
/**
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useDepsArray(deps: readonly any[] | undefined): boolean;
export declare class ElementRef<Element extends AnyElement = AnyElement> implements JSX.ElementRef {
	readonly element: Element | null;
	protected effects: AlienEffects | void;
	setElement(element: Element | null): void;
	protected attach?(element: Element): AlienEffects | void;
	protected detach?(element: Element): void;
}
/**
 * Same as `ElementRef` except a delegate (provided to the constructor) is
 * called for the `attach` and `detach` events.
 */
export declare class DelegatedElementRef<Element extends AnyElement = AnyElement, Key = any> extends ElementRef<Element> {
	delegate: ElementRefDelegate<Element, Key>;
	key: Key;
	constructor(delegate: ElementRefDelegate<Element, Key>, key: Key);
	protected attach(element: Element): AlienEffects | void;
	protected detach(element: Element): void;
}
/**
 * A delegate for `DelegatedElementRef`.
 */
export interface ElementRefDelegate<Element extends AnyElement, DelegateState> {
	attach?(element: Element, ref: DelegatedElementRef<Element, DelegateState>): AlienEffects | void;
	detach?(element: Element, ref: DelegatedElementRef<Element, DelegateState>): void;
}
export declare const useElementArray: <T extends Element>() => ElementArray<T>;
export declare class ElementArray<T extends AnyElement = AnyElement> extends Array<ElementRef<T> | undefined> {
	/**
	 * Get the element at the given index. Negative indices are allowed.
	 */
	get(index: number): T | null;
	/**
	 * Get an element ref to hold an element for the given index. Pass the result
	 * as the `ref` prop of the JSX element whose DOM node you need a reference
	 * to.
	 */
	bind(index: number): ElementRef<T>;
	protected attach(_element: T, ref: DelegatedElementRef<T, number>): void;
	protected detach(_element: T, ref: DelegatedElementRef<T, number>): void;
}
export declare const useElementMap: <K, T extends Element = Element>() => ElementMap<K, T>;
export declare class ElementMap<Key, Element extends AnyElement = AnyElement> {
	private map;
	/**
	 * Get the element at the given key. Returns `null` if the key is not found.
	 */
	get(key: Key): Element | null;
	/**
	 * Get an element ref to hold an element for the given key. Pass the result as
	 * the `ref` prop of the JSX element whose DOM node you need a reference to.
	 */
	bind(key: Key): ElementRef<Element>;
	protected attach(_element: Element, ref: DelegatedElementRef<Element>): void;
	protected detach(_element: Element, ref: DelegatedElementRef<Element>): void;
}
export declare const useElementProxy: <T extends Element>(effect?: ((element: T) => EffectResult) | undefined) => ElementProxy<T>;
export type EventTargetEffect<Target extends EventTarget = EventTarget> = (target: Target | Document) => EffectResult;
/**
 * Create an element ref that attaches an effect when the element is set.
 *
 * If the ref is not attached to a JSX element at render time, the effect will
 * be attached to the `document` instead.
 *
 * 🪝 This hook adds 2 to the hook offset.
 */
export declare function useEventTarget<Target extends EventTarget>(effect: EventTargetEffect<Target>): {
	setElement: (element: HTMLElement | null) => void;
	enabled: boolean;
	enable: (target: HTMLElement | Document) => EffectResult;
	dispose?: (() => void) | undefined;
};
export declare function useForceUpdate(): <T>(compute?: ((oldRefs: Set<Ref<any> & {
	_value: any;
	_observers: Set<Observer>;
	_depth: number;
	_isObserved: (observer: Observer, isObserved: boolean) => void;
}>) => T) | undefined) => T;
/**
 * By default, this hook returns a stable guid. If the `reset` argument is true,
 * the guid will change on every render. If the `reset` argument is later
 * changed to false, the last used guid will remain stable.
 *
 * It can be used to conditionally bust caches (i.e. for debugging or
 * development purposes), but it's also good for generating a stable guid.
 *
 * The guid is guaranteed to be truthy. To avoid overflow issues, the guid
 * starts at `Number.MIN_SAFE_INTEGER` instead of 1, but 0 is always skipped. If
 * this approach isn't good enough, you can pass a custom `generateId` function.
 */
export declare function useGlobalId(reset?: boolean): number;
export declare function useGlobalId<Id extends string | number = number>(reset: boolean | null | undefined, generateId: () => Id): Id;
/**
 * For conditional hooks, the `useHookOffset` function can be used in the
 * alternate branch to ensure that the hook index is consistent between the two
 * branches.
 *
 * Note: This approach is **fragile** and should be used sparingly, but it's
 * very useful for custom hooks whose behavior is flexible based on input
 * parameters.
 *
 * Built-in hooks like `useConst`, `useMemo`, and `useComputed` require an
 * offset of 1, while `useRef`, `useEffect`, and `useObserver` require an offset
 * of 2. For other hooks, you must look at their implementation to calculate the
 * required offset. Statements like `component.nextHookIndex++` also increase
 * the required offset (see `useConst` for an example).
 */
export declare function useHookOffset(offset: number): void;
/**
 * Set up an effect that repeats at a fixed time interval.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare const useInterval: (callback: () => void, delay: number | null, deps?: readonly any[]) => void;
export interface KeyBindingEvent<Target extends Document | HTMLElement = any> {
	target: Target;
	repeat: boolean;
	stopPropagation(): void;
	preventDefault(): void;
}
type Split<T extends string> = T extends `${infer First}${infer Rest}` ? First | Split<Rest> : never;
type LetterKey = Split<"ABCDEFGHIJKLMNOPQRSTUVWXYZ">;
type DigitKey = Split<"0123456789">;
type SymbolKey = Split<"!@#$%^&*()_+-=[]{}|\\;:,.?<>/'\" ">;
export type KeyCombo = readonly KeyCombo[] | `${Key}` | LetterKey | DigitKey | SymbolKey | false | null | undefined;
export declare function useKeyBinding<Target extends Document | HTMLElement>(combo: KeyCombo, onKeyDown?: (event: KeyBindingEvent<Target>) => EffectResult, options?: AddEventListenerOptions): {
	/**
	 * Equals true when the key binding is activated.
	 * @observable
	 */
	isActive: boolean;
	effect: {
		dispose(): void;
	} | null;
	combo: Set<string>;
	onKeyDown: ((event: KeyBindingEvent<any>) => EffectResult) | undefined;
	onKeyUp: EffectResult | undefined;
	setElement: (element: HTMLElement) => void;
	enable: (target: HTMLElement | Document) => EffectResult;
};
export type KeyBinding = ReturnType<typeof initKeyBinding>;
declare const initKeyBinding: (callback: ((event: KeyBindingEvent) => void) | undefined, options: AddEventListenerOptions | undefined) => {
	/**
	 * Equals true when the key binding is activated.
	 * @observable
	 */
	isActive: boolean;
	effect: Disposable$1 | null;
	combo: Set<string>;
	onKeyDown: ((event: KeyBindingEvent) => EffectResult) | undefined;
	onKeyUp: EffectResult | undefined;
	setElement: (element: HTMLElement) => void;
	enable: (target: Document | HTMLElement) => EffectResult;
};
/**
 * @experimental
 */
export declare function defineMachine<T extends MachineType>(setup: (params: Readonly<MachineParams<T>>, update: MachineUpdater<T>, machine: Machine<T>) => MachineState<T>): MachineClass<T>;
export interface MachineClass<T extends MachineType = any> {
	new (params: Readonly<MachineParams<T>>, onChange?: MachineCallback<T>): Machine<T>;
}
export type MachineType<Params extends object | void = any, State extends {
	value: string;
} = any> = (params: Params) => State;
export type MachineState<T extends MachineType, S extends MachineValue<T> = any> = T extends MachineType<any, infer State> ? Extract<State, {
	value: S;
}> : never;
export type MachineValue<T extends MachineType> = T extends MachineType<any, infer State> ? State["value"] : never;
export type MachineValueWithKey<T extends MachineType, Key extends keyof any> = Extract<MachineState<T>, {
	[K in Key]: any;
}>["value"];
export type MachineParams<T extends MachineType> = T extends MachineType<infer Params> ? Params : never;
export type MachineCallback<T extends MachineType> = (state: Readonly<MachineState<T>>, self: Machine<T>) => void;
type VoidMachineValue<T extends MachineType> = MachineState<T> extends infer State ? State extends {
	value: MachineValue<T>;
} ? {
	value: any;
} extends State ? State["value"] : never : never : never;
export type MachineUpdater<T extends MachineType> = {
	<State extends MachineState<T>>(newState: State): State;
	<Value extends VoidMachineValue<T>>(value: Value): Extract<MachineState<T>, {
		value: Value;
	}>;
	<Value extends MachineValue<T>, State extends Extract<MachineState<T>, {
		value: Value;
	}>>(value: Value, newState: Omit<State, "value">): State;
};
export type MachineProxy<T extends MachineType, State extends MachineValue<T> = any> = ProxiedMachine<T, State> & Readonly<AssumedState<MachineState<T>>>;
interface ProxiedMachine<T extends MachineType, State extends MachineValue<T>> extends Machine<T, State> {
	is<Value extends MachineValue<T>>(value: Value | Value[]): this is MachineProxy<T, Value>;
	has<Key extends AllKeys<MachineState<T>>>(key: Key): this is MachineProxy<T, MachineValueWithKey<T, Key>>;
}
type OmitValue<T> = T extends any ? Remap<Omit<T, "value">> : never;
type AssumedState<T> = Remap<Intersect<[
	T
] extends [
	{
		value: infer V;
	}
] ? {
	value: V;
} & OmitValue<T> : never>>;
export declare class Machine<T extends MachineType, State extends MachineValue<T> = any> {
	readonly params: Readonly<MachineParams<T>>;
	readonly stateRef: ReadonlyRef<MachineState<T, State>>;
	constructor(params: Readonly<MachineParams<T>>, stateRef: ReadonlyRef<MachineState<T, State>>);
	get state(): Readonly<MachineState<T, State>>;
	get value(): Extract<MachineValue<T>, State>;
	peek(): any;
	is<Value extends MachineValue<T>>(value: Value | Value[]): this is Machine<T, Value>;
	has<Key extends AllKeys<MachineState<T>>>(key: Key): this is Machine<T, MachineValueWithKey<T, Key>>;
	assert<Value extends MachineValue<T>>(value: Value): Readonly<MachineState<T, Value>>;
}
export declare function toMachineProxy<T extends MachineType>(machine: Machine<T>): MachineProxy<T>;
export declare function useMachineProxy<T extends MachineType<void>>(constructor: MachineClass<T>, onChange?: MachineCallback<T>): MachineProxy<T>;
export declare function useMachineProxy<T extends MachineType>(constructor: MachineClass<T>, params: MachineParams<T>, onChange?: MachineCallback<T>): MachineProxy<T>;
/**
 * Save a value until its dependencies change. If a function is passed, it‘s
 * called with `peek()` and its result is saved as the value.
 *
 * The value is discarded when the component is hot-reloaded.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useMemo<T>(arg: T | (() => T), deps?: readonly any[]): T;
/**
 * Return the same object reference unless its properties have changed. Strict
 * equality is used to determine if a property has changed. Property order does
 * not matter. Undefined values are identical to omitted properties.
 */
export declare function useObjectMemo<T extends object>(o: T): T;
/**
 * Observe a single ref.
 *
 * 🪝 This hook adds 2 to the hook offset.
 */
export declare function useObserver<T>(ref: ReadonlyRef<T> | Falsy, onChange: (value: T, oldValue: T) => void): void;
/**
 * Observe any refs accessed by the effect.
 *
 * 🪝 This hook adds 2 to the hook offset.
 */
export declare function useObserver(effect: EffectCallback | Falsy, deps: readonly any[]): void;
/**
 * Save the given `value` for the next render.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function usePrevious<T>(value: T): T | undefined;
export declare function usePrevious<T>(value: T, deps: readonly any[]): T | undefined;
/**
 * Create an open promise that can be recreated when the dependencies change and
 * when a component is hot-reloaded.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function usePromise<T>(deps: readonly any[]): OpenPromise<T>;
/**
 * Create an open promise that exists for as long as its component instance
 * without an ability to recreate it.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function usePromise<T>(): OpenPromise<T>;
/**
 * Create an observable ref that persists between renders. Unlike the `useMemo`
 * hook, the ref is not recreated when the component is hot-reloaded.
 *
 * You may destructure the ref into a `[value, setValue]` tuple.
 *
 * 🪝 This hook adds 2 to the hook offset.
 */
export declare function useRef<T>(): Ref<T | undefined> & [
	value: T | undefined,
	set: Ref<T | undefined>[1]
];
export declare function useRef<T>(init: T | (() => T)): Ref<T> & [
	value: T,
	set: Ref<T>[1]
];
export declare function useRef<T>(init: T | (() => T), deps: readonly any[]): Ref<T> & [
	value: T,
	set: Ref<T>[1]
];
/**
 * This hook is useful for generating a guid that changes on each render
 * where a particular condition is true or a dependency array has
 * changed.
 *
 * 🪝 This hook adds 4 to the hook offset.
 */
export declare function useResetId(reset: ResetOption): number;
export declare function useResetId(reset: ResetOption | undefined): number | false;
export declare function useResetId(reset: string): string;
export declare function useResetId(reset: string | undefined): string | false;
export declare function useResetId(reset: string | ResetOption | undefined): string | number | false;
export declare function useResetId(compute: () => ResetOption): ReadonlyRef<number>;
type ResetOption = boolean | readonly any[];
export declare function useScrollStart(handler: (event: Event) => void): {
	setElement: (element: HTMLElement | null) => void;
	enabled: boolean;
	enable: (target: HTMLElement | Document) => EffectResult;
	dispose?: (() => void) | undefined;
};
export declare function useQuerySelector<Element extends AnyElement>(selector: string, context?: AnyElement): ReadonlyRef<Element | null> & Iterable<Element | null>;
export declare function useQuerySelectorAll<Element extends AnyElement>(selector: string, context?: HTMLElement): ReadonlyRef<Set<Element>> & Iterable<Set<Element>>;
export declare function useSpring<Element extends HTMLOrSVGElement$1>(element: Element, animations: SpringAnimation<Element> | readonly SpringAnimation<Element>[], shouldRun?: boolean | null): void;
/**
 * This creates a stable callback (i.e. its reference never changes) whose
 * implementation is updated on every render.
 *
 * This is most beneficial for callbacks used in run-once effects.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useStableCallback<T extends (...args: any[]) => any>(callback: T): T;
export declare function useStableCallback<T extends (...args: any[]) => void>(callback: T | Falsy): T;
export type SetState<T> = Ref<T>[1];
/**
 * Identical to `useState` in React. The idiomatic way to declare UI state in
 * AlienDOM is through the `useRef` hook, which you can destructure into a tuple
 * just like `useState`. For this reason, you should avoid `useState` unless
 * you're migrating a project from React.
 *
 * 🪝 This hook adds 2 to the hook offset.
 */
export declare const useState: {
	<T>(): [
		value: T | undefined,
		set: (arg: T | ((value: T | undefined) => T | undefined) | undefined) => T | undefined
	];
	<T_1>(init: T_1 | (() => T_1), deps?: readonly any[]): [
		value: T_1,
		set: (arg: T_1 | ((value: T_1) => T_1)) => T_1
	];
};
/**
 * Update the style of an element during render. This hook is preferred
 * to calling `element.css` directly, because it updates the newest
 * version of the `element`. The style is applied through morphdom,
 * which means it won't interfere with animations.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useStyle(element: HTMLOrSVGElement$1 | readonly HTMLOrSVGElement$1[], style: CSSAttributes | Falsy, deps?: readonly any[]): void;
/**
 * Observable access within the useStyle callback does not trigger a
 * re-render. Instead, the element is updated directly. This is useful
 * for performance reasons when the style is updated frequently or the
 * component is expensive to re-render.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useStyle(element: HTMLOrSVGElement$1 | readonly HTMLOrSVGElement$1[], style: () => CSSAttributes | Falsy, deps: readonly any[]): void;
/**
 * Shorthand for `useEffect` with a `!isFirstRun` check inside the effect.
 */
export declare function useUpdateEffect<State = {}>(effect: EffectCallback<State> | Falsy, deps: readonly any[]): void;
/**
 * This hook is useful whenever you have an externally managed DOM node (or a
 * collection of nodes) that need to be mounted and unmounted to/from a JSX
 * parent element. One example is `useArrayView` which uses this hook to
 * mount/unmount the nodes derived from the array to/from a parent element.
 *
 * Create a DOM node that notifies when it's mounted and unmounted. The given
 * `view` function is called whenever the node is mounted to the DOM, and the
 * function it returns is called whenever the node is unmounted. The node may be
 * mounted/unmounted multiple times and the `view` function will be called each
 * time. When the `deps` change, a new node is created and the old node is
 * unmounted.
 *
 * ⚠️ To receive an unmount notification, you need to use the `unmount` function
 * provided by AlienDOM (i.e. call `unmount` on the returned node or one of its
 * ancestors).
 *
 * 🪝 This hook adds 2 to the hook offset.
 */
export declare function useView(view: (parentNode: ParentNode) => () => void, deps: readonly any[]): ChildNode;
export type UseVisibilityOptions = {
	root?: Element | ElementProxy | Document | null;
	rootMargin?: string;
	threshold?: number | number[];
	onChange?: (visible: boolean, entry: IntersectionObserverEntry) => void;
};
export declare function useVisibility(target: HTMLOrSVGElement$1 | ElementProxy, options?: UseVisibilityOptions, deps?: readonly any[]): ReadonlyRef<boolean>;
type Yield = VarArgs<DisposablePromise<any> | Promise<any> | (() => void) | Falsy>;
export declare function useYieldingEffect(effect: () => Generator<any, EffectResult, Yield>, deps: readonly any[]): void;
declare const enum EffectFlags {
	Once = 1,
	Async = 2
}
interface Item {
	next?: this | Falsy;
	prev?: this | Falsy;
}
declare class LinkedList<T extends Item> {
	first: T | Falsy;
	last: T | Falsy;
	add(item: T, prepend?: boolean): void;
	remove(item: T): void;
	forEach<This = any>(callback: (item: T) => void, context?: This): void;
}
export interface AlienEffect<Target = any, Args extends any[] = any[], Async extends boolean = boolean> {
	(target: Target, ...args: boolean extends Async ? any[] : Async extends true ? [
		AbortSignal,
		...Args
	] : Args): Async extends true ? Promisable<(() => void) | void> : (() => void) | void;
	context?: AlienEffects;
	target?: Target;
	args?: Args;
	async?: Async;
	disable?: () => void;
	once?: boolean;
	next?: AlienEffect | null;
	prev?: AlienEffect | null;
}
declare const enum AlienEffectState {
	Disabled = 0,
	Disabling = 1,
	Enabling = 2,
	Enabled = 3
}
/**
 * Hook into an element's lifecycle (mount, unmount, enable, disable).
 *
 * Any `enable` or `disable` callbacks will be run when the element is
 * mounted or unmounted, respectively. If the element is already mounted,
 * any `enable` callbacks will be run immediately.
 */
export declare class AlienEffects {
	state: AlienEffectState;
	mounted: boolean;
	rootNode?: Node;
	effects?: LinkedList<AlienEffect> | null;
	currentEffect: AlienEffect | null;
	abortCtrl?: AbortController;
	constructor(callback?: () => void);
	get enabled(): boolean;
	get partiallyEnabled(): boolean;
	/**
	 * Run all current and future effects until disabled.
	 */
	enable(): void;
	/**
	 * Disable all current effects and prevent future effects from running.
	 */
	disable(destroy?: boolean): void;
	/** @internal */
	remove(effect: AlienEffect): void;
	/**
	 * Add an effect to run when `this` is enabled. If `this` is currently
	 * enabled, the effect will run immediately.
	 *
	 * If the given `effect` is already known to `this`, it can still have its
	 * target and arguments changed through this method.
	 */
	run(effect: AlienEffect<void, [
	], false>): Disposable$1<typeof effect>;
	run<Args extends any[]>(effect: AlienEffect<void, Args, false>, args: Args): Disposable$1<typeof effect>;
	run<T extends object | void, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, false>, target: T, args?: Args): Disposable$1<typeof effect>;
	/**
	 * Add a callback to run when the scope is next enabled.
	 */
	runOnce(effect: AlienEffect<void, [
	], false>): Disposable$1<typeof effect>;
	runOnce<Args extends any[]>(effect: AlienEffect<void, Args, false>, args: Args): Disposable$1<typeof effect>;
	runOnce<T extends object, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, false>, target: T, args?: Args): Disposable$1<typeof effect>;
	runAsync(effect: AlienEffect<void, [
	], true>): Disposable$1<typeof effect>;
	runAsync<Args extends any[]>(effect: AlienEffect<void, Args, true>, args: Args): Disposable$1<typeof effect>;
	runAsync<T extends object, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, true>, target: T, args?: Args): Disposable$1<typeof effect>;
	runOnceAsync(effect: AlienEffect<void, [
	], true>): typeof effect;
	runOnceAsync<Args extends any[]>(effect: AlienEffect<void, Args, true>, args: Args): typeof effect;
	runOnceAsync<T extends object, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, true>, target: T, args?: Args): typeof effect;
	protected _runEffect(effect: AlienEffect): void;
}
/**
 * A special type of AlienEffects that is only enabled when the element is
 * mounted. It relies on a `MutationObserver` attached to a document or shadow
 * root, so it knows when the element is connected.
 */
export declare class AlienMountEffects<Element extends AnyElement = any> extends AlienEffects {
	readonly element: Element | Comment;
	protected _mountEffect: Disposable$1 | null;
	constructor(element: Element | Comment, rootNode?: Node);
	enable(): void;
	disable(destroy?: boolean): void;
	protected enableOnceMounted(element: Element | Comment, rootNode?: Node): void;
}
/**
 * Bound effects have their `target` and `args` pre-defined.
 */
export type AlienBoundEffect<Target = any, Args extends any[] = any, Async extends boolean = boolean> = {
	enable: AlienEffect<Target, Args, Async>;
	target?: Target;
	args?: Args;
};
/**
 * If the `currentEffects` context (or the given `context`) is enabled,
 * this effect will be enabled immediately.
 */
export declare function createEffect<Effect extends AlienEffect<void, [
], false> | AlienBoundEffect<any, any, false>>(effect: Effect, prepend?: boolean, context?: AlienEffects, flags?: EffectFlags.Once): Disposable$1<typeof effect>;
export declare function createEffect<Effect extends AlienEffect<void, [
], true> | AlienBoundEffect<any, any, true>>(effect: Effect, prepend: boolean | undefined, context: AlienEffects | undefined, flags: EffectFlags.Async): Disposable$1<typeof effect>;
export declare const createOnceEffect: <Effect extends AlienEffect<void, [
], false> | AlienBoundEffect<any, any, false>>(effect: Effect, prepend?: boolean, context?: AlienEffects) => Disposable$1<Effect>;
export declare const createAsyncEffect: <Effect extends AlienEffect<void, [
], true> | AlienBoundEffect<any, any, true>>(effect: Effect, prepend?: boolean, context?: AlienEffects) => Disposable$1<Effect>;
export type AlienEffectType<Args extends any[]> = (...args: Args) => Args extends [
	infer Target,
	...infer Args
] ? Disposable$1<AlienBoundEffect<Target, Args>> : never;
export declare function defineEffectType<Args extends any[]>(enable: (...args: Args) => EffectResult): AlienEffectType<Args>;
/**
 * Useful when an effect wants to remove itself. It should call this
 * when setting itself up.
 */
export declare function getCurrentEffect(): AlienEffect<any, any[], boolean> | null | undefined;
declare const styleDeconflict: {
	readonly border: "cssBorder";
	readonly content: "cssContent";
	readonly filter: "cssFilter";
	readonly height: "cssHeight";
	readonly transform: "cssTransform";
	readonly translate: "cssTranslate";
	readonly width: "cssWidth";
} & {
	readonly cssBorder: "border";
	readonly cssContent: "content";
	readonly cssFilter: "filter";
	readonly cssHeight: "height";
	readonly cssTransform: "transform";
	readonly cssTranslate: "translate";
	readonly cssWidth: "width";
};
type AlienStyleDeconflict = typeof styleDeconflict;
type AlienStyleMethods<Element extends AnyElement> = {
	[P in keyof CSS$1.Properties as P extends keyof AlienStyleDeconflict ? AlienStyleDeconflict[P] : P]: {
		(): CSS$1.Properties<CSSLength>[P];
		(value: CSS$1.Properties<CSSLength>[P] | null): Element;
	};
};
type AlienEventMethod<This extends AnyElement, Event extends AnyEvent = AnyEvent> = (callback: (this: This, event: AlienEvent<Event, This>) => void, options?: boolean | AddEventListenerOptions) => Disposable$1<AlienBoundEffect<This>>;
type AlienEventMethods<This extends AnyElement> = {
	[P in keyof Omit<HTMLElementEventMap, "change"> as AlienEventType<P>]: AlienEventMethod<This, HTMLElementEventMap[P]>;
};
type AlienEventType<Event extends string> = `${AlienEventPrefix}${CamelCaseHTMLEvent<Event>}${AlienEventSuffix<Event>}`;
type AlienEventPrefix = "on" | "one";
type AlienEventSuffix<Event extends string> = (Event extends HTMLBubblingEvents ? "Capture" : never) | "";
type CamelCaseHTMLEvent<Event extends string> = Event extends `${HTMLEventPrefix}${infer Suffix}` ? Event extends `${infer Prefix extends string}${Suffix}` ? `${Capitalize<Prefix>}${CamelCaseHTMLEvent<Suffix>}` : never : Capitalize<Event>;
type HTMLEventPrefix = "animation" | "aux" | "before" | "can" | "composition" | "context" | "cue" | "dbl" | "drag" | "duration" | "focus" | "form" | "got" | "loaded" | "lost" | "mouse" | "pointer" | "rate" | "select" | "selection" | "slot" | "time" | "touch" | "transition" | "volume";
type HTMLBubblingEvents = "blur" | "change" | "click" | "dblclick" | "error" | "focus" | "keydown" | "keyup" | "load" | "mousedown" | "mousemove" | "mouseout" | "mouseover" | "mouseup" | "reset" | "resize" | "scroll" | "select" | "submit" | "unload";
interface AlienNodeList<Element extends Node> extends ReturnType<typeof defineAlienNodeList<Element>> {
}
declare function defineAlienNodeList<T extends Node>(): {
	[Symbol.iterator](this: NodeListOf<T>): IterableIterator<T>;
	map<U>(this: NodeListOf<T>, iterator: (value: T, index: number) => U): U[];
	filter<U_1 extends T = T>(this: NodeListOf<T>, selector: string | ((value: T, index: number) => any)): U_1[];
	mapFilter<U_2>(this: NodeListOf<T>, iterator: (value: T, index: number) => void | U_2 | null | undefined): U_2[];
	find<U_3 extends T = T>(this: NodeListOf<T>, selector: string | ((value: T, index: number) => any)): U_3 | undefined;
};
export interface AlienElementList<Element extends Node = HTMLOrSVGElement$1> extends NodeListOf<Element>, AlienNodeList<Element> {
	[index: number]: Element;
	forEach(iterator: (value: Element, key: number, parent: AlienElementList<Element>) => void): void;
	forEach<This>(iterator: (this: This, value: Element, key: number, parent: AlienElementList<Element>) => void, thisArg: This): void;
}
export type AlienElementIterator<Element extends AnyElement> = Iterable<Element> & {
	first(): Element | null;
	next(): Element | null;
};
export type AlienEvent<Event extends AnyEvent = AnyEvent, Element extends AnyElement = HTMLOrSVGElement$1> = Event & {
	currentTarget: Element;
	target: AnyElement;
} & (Event extends {
	relatedTarget: EventTarget;
} ? {
	relatedTarget: AnyElement;
} : unknown);
type AlienParentElement<Element extends AnyElement> = (Element extends SVGElement ? SVGElement : never) | HTMLElement | Document;
export declare class AlienElement<Element extends AnyElement = HTMLOrSVGElement$1> {
	$<SelectedElement extends AlienTag<Element> = Element>(selector: string): AlienSelect<SelectedElement, this> | null;
	$$<SelectedElement extends AlienTag<Element> = Element>(selector: string): AlienElementList<AlienSelect<SelectedElement, this>>;
	siblings<SelectedElement extends AlienTag<Element> = Element>(selector?: string): AlienElementIterator<AlienSelect<SelectedElement, this>>;
	filter<SelectedElement extends AnyElement = Element>(selector: string): AlienSelect<SelectedElement, this> | null;
	replaceText(value: string): this;
	replaceText(value: () => string): Disposable$1<AlienBoundEffect<Element>>;
	empty(): this;
	appendTo(parent: AlienParentElement<Element>): this;
	prependTo(parent: AlienParentElement<Element>): this;
	hasClass(name: string): boolean;
	addClass(name: string): this;
	removeClass(name: string): this;
	removeMatchingClasses(pattern: RegExp | ((name: string) => boolean | void)): this;
	toggleClass(name: string, value?: boolean): boolean;
	/**
	 * Returns the first class name that matches the given pattern.
	 *
	 * If a capturing group exists in the pattern, the captured value will
	 * be returned. Otherwise, the entire match will be returned.
	 *
	 * An empty string is returned if no match is found.
	 */
	matchClass(pattern: RegExp): string;
	css(style: CSSAttributes): this;
	set(props: JSX.InferAttributes<Element>): this;
	spring(animations: AnimationsParam<Element>): this;
}
export interface AlienElement<Element extends AnyElement> extends AnyElement, AlienEventMethods<Element>, AlienStyleMethods<Element> {
	/**
	 * Replace this node with its children.
	 */
	unwrap<T extends Node = ChildNode>(): T[];
	/**
	 * ⚠️ It's not safe to call this from within a `selfUpdating`
	 * component's render function (if this element is returned by the
	 * component).
	 */
	effects(): AlienMountEffects<FromElementProxy<this>>;
	effect(effect: AlienEffect<void, [
	], false>): Disposable$1<typeof effect>;
	effect<Args extends any[]>(effect: AlienEffect<void, Args, false>, args: Args): Disposable$1<typeof effect>;
	effect<T extends object | void, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, false>, target: T, args?: Args): Disposable$1<typeof effect>;
	effectOnce(effect: AlienEffect<void, [
	], false>): Disposable$1<typeof effect>;
	effectOnce<Args extends any[]>(effect: AlienEffect<void, Args, false>, args: Args): Disposable$1<typeof effect>;
	effectOnce<T extends object | void, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, false>, target: T, args?: Args): Disposable$1<typeof effect>;
	effectAsync(effect: AlienEffect<void, [
	], true>): Disposable$1<typeof effect>;
	effectAsync<Args extends any[]>(effect: AlienEffect<void, Args, true>, args: Args): Disposable$1<typeof effect>;
	effectAsync<T extends object | void, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, true>, target: T, args?: Args): Disposable$1<typeof effect>;
	effectOnceAsync(effect: AlienEffect<void, [
	], true>): Disposable$1<typeof effect>;
	effectOnceAsync<Args extends any[]>(effect: AlienEffect<void, Args, true>, args: Args): Disposable$1<typeof effect>;
	effectOnceAsync<T extends object | void, Args extends any[] = [
	]>(effect: AlienEffect<T, Args, true>, target: T, args?: Args): Disposable$1<typeof effect>;
}
export interface DOMAttributes<T> {
	onCopy?: ClipboardEventHandler<T>;
	onCopyCapture?: ClipboardEventHandler<T>;
	onCut?: ClipboardEventHandler<T>;
	onCutCapture?: ClipboardEventHandler<T>;
	onPaste?: ClipboardEventHandler<T>;
	onPasteCapture?: ClipboardEventHandler<T>;
	onCompositionEnd?: CompositionEventHandler<T>;
	onCompositionEndCapture?: CompositionEventHandler<T>;
	onCompositionStart?: CompositionEventHandler<T>;
	onCompositionStartCapture?: CompositionEventHandler<T>;
	onCompositionUpdate?: CompositionEventHandler<T>;
	onCompositionUpdateCapture?: CompositionEventHandler<T>;
	onFocus?: FocusEventHandler<T>;
	onFocusCapture?: FocusEventHandler<T>;
	onBlur?: FocusEventHandler<T>;
	onBlurCapture?: FocusEventHandler<T>;
	onChange?: FormEventHandler<T>;
	onChangeCapture?: FormEventHandler<T>;
	onBeforeInput?: FormEventHandler<T>;
	onBeforeInputCapture?: FormEventHandler<T>;
	onInput?: FormEventHandler<T>;
	onInputCapture?: FormEventHandler<T>;
	onReset?: FormEventHandler<T>;
	onResetCapture?: FormEventHandler<T>;
	onSubmit?: FormEventHandler<T>;
	onSubmitCapture?: FormEventHandler<T>;
	onInvalid?: FormEventHandler<T>;
	onInvalidCapture?: FormEventHandler<T>;
	onLoad?: EventHandler<Event, T>;
	onLoadCapture?: EventHandler<Event, T>;
	onError?: EventHandler<Event, T>;
	onErrorCapture?: EventHandler<Event, T>;
	onKeyDown?: KeyboardEventHandler<T>;
	onKeyDownCapture?: KeyboardEventHandler<T>;
	onKeyPress?: KeyboardEventHandler<T>;
	onKeyPressCapture?: KeyboardEventHandler<T>;
	onKeyUp?: KeyboardEventHandler<T>;
	onKeyUpCapture?: KeyboardEventHandler<T>;
	onAbort?: EventHandler<Event, T>;
	onAbortCapture?: EventHandler<Event, T>;
	onCanPlay?: EventHandler<Event, T>;
	onCanPlayCapture?: EventHandler<Event, T>;
	onCanPlayThrough?: EventHandler<Event, T>;
	onCanPlayThroughCapture?: EventHandler<Event, T>;
	onDurationChange?: EventHandler<Event, T>;
	onDurationChangeCapture?: EventHandler<Event, T>;
	onEmptied?: EventHandler<Event, T>;
	onEmptiedCapture?: EventHandler<Event, T>;
	onEncrypted?: EventHandler<Event, T>;
	onEncryptedCapture?: EventHandler<Event, T>;
	onEnded?: EventHandler<Event, T>;
	onEndedCapture?: EventHandler<Event, T>;
	onLoadedData?: EventHandler<Event, T>;
	onLoadedDataCapture?: EventHandler<Event, T>;
	onLoadedMetadata?: EventHandler<Event, T>;
	onLoadedMetadataCapture?: EventHandler<Event, T>;
	onLoadStart?: EventHandler<Event, T>;
	onLoadStartCapture?: EventHandler<Event, T>;
	onPause?: EventHandler<Event, T>;
	onPauseCapture?: EventHandler<Event, T>;
	onPlay?: EventHandler<Event, T>;
	onPlayCapture?: EventHandler<Event, T>;
	onPlaying?: EventHandler<Event, T>;
	onPlayingCapture?: EventHandler<Event, T>;
	onProgress?: EventHandler<Event, T>;
	onProgressCapture?: EventHandler<Event, T>;
	onRateChange?: EventHandler<Event, T>;
	onRateChangeCapture?: EventHandler<Event, T>;
	onSeeked?: EventHandler<Event, T>;
	onSeekedCapture?: EventHandler<Event, T>;
	onSeeking?: EventHandler<Event, T>;
	onSeekingCapture?: EventHandler<Event, T>;
	onStalled?: EventHandler<Event, T>;
	onStalledCapture?: EventHandler<Event, T>;
	onSuspend?: EventHandler<Event, T>;
	onSuspendCapture?: EventHandler<Event, T>;
	onTimeUpdate?: EventHandler<Event, T>;
	onTimeUpdateCapture?: EventHandler<Event, T>;
	onVolumeChange?: EventHandler<Event, T>;
	onVolumeChangeCapture?: EventHandler<Event, T>;
	onWaiting?: EventHandler<Event, T>;
	onWaitingCapture?: EventHandler<Event, T>;
	onAuxClick?: MouseEventHandler<T>;
	onAuxClickCapture?: MouseEventHandler<T>;
	onClick?: MouseEventHandler<T>;
	onClickCapture?: MouseEventHandler<T>;
	onContextMenu?: MouseEventHandler<T>;
	onContextMenuCapture?: MouseEventHandler<T>;
	onDblClick?: MouseEventHandler<T>;
	onDblClickCapture?: MouseEventHandler<T>;
	onDrag?: DragEventHandler<T>;
	onDragCapture?: DragEventHandler<T>;
	onDragEnd?: DragEventHandler<T>;
	onDragEndCapture?: DragEventHandler<T>;
	onDragEnter?: DragEventHandler<T>;
	onDragEnterCapture?: DragEventHandler<T>;
	onDragExit?: DragEventHandler<T>;
	onDragExitCapture?: DragEventHandler<T>;
	onDragLeave?: DragEventHandler<T>;
	onDragLeaveCapture?: DragEventHandler<T>;
	onDragOver?: DragEventHandler<T>;
	onDragOverCapture?: DragEventHandler<T>;
	onDragStart?: DragEventHandler<T>;
	onDragStartCapture?: DragEventHandler<T>;
	onDrop?: DragEventHandler<T>;
	onDropCapture?: DragEventHandler<T>;
	onMouseDown?: MouseEventHandler<T>;
	onMouseDownCapture?: MouseEventHandler<T>;
	onMouseEnter?: MouseEventHandler<T>;
	onMouseLeave?: MouseEventHandler<T>;
	onMouseMove?: MouseEventHandler<T>;
	onMouseMoveCapture?: MouseEventHandler<T>;
	onMouseOut?: MouseEventHandler<T>;
	onMouseOutCapture?: MouseEventHandler<T>;
	onMouseOver?: MouseEventHandler<T>;
	onMouseOverCapture?: MouseEventHandler<T>;
	onMouseUp?: MouseEventHandler<T>;
	onMouseUpCapture?: MouseEventHandler<T>;
	onSelect?: EventHandler<Event, T>;
	onSelectCapture?: EventHandler<Event, T>;
	onTouchCancel?: TouchEventHandler<T>;
	onTouchCancelCapture?: TouchEventHandler<T>;
	onTouchEnd?: TouchEventHandler<T>;
	onTouchEndCapture?: TouchEventHandler<T>;
	onTouchMove?: TouchEventHandler<T>;
	onTouchMoveCapture?: TouchEventHandler<T>;
	onTouchStart?: TouchEventHandler<T>;
	onTouchStartCapture?: TouchEventHandler<T>;
	onPointerDown?: PointerEventHandler<T>;
	onPointerDownCapture?: PointerEventHandler<T>;
	onPointerMove?: PointerEventHandler<T>;
	onPointerMoveCapture?: PointerEventHandler<T>;
	onPointerUp?: PointerEventHandler<T>;
	onPointerUpCapture?: PointerEventHandler<T>;
	onPointerCancel?: PointerEventHandler<T>;
	onPointerCancelCapture?: PointerEventHandler<T>;
	onPointerEnter?: PointerEventHandler<T>;
	onPointerEnterCapture?: PointerEventHandler<T>;
	onPointerLeave?: PointerEventHandler<T>;
	onPointerLeaveCapture?: PointerEventHandler<T>;
	onPointerOver?: PointerEventHandler<T>;
	onPointerOverCapture?: PointerEventHandler<T>;
	onPointerOut?: PointerEventHandler<T>;
	onPointerOutCapture?: PointerEventHandler<T>;
	onGotPointerCapture?: PointerEventHandler<T>;
	onGotPointerCaptureCapture?: PointerEventHandler<T>;
	onLostPointerCapture?: PointerEventHandler<T>;
	onLostPointerCaptureCapture?: PointerEventHandler<T>;
	onScroll?: UIEventHandler<T>;
	onScrollCapture?: UIEventHandler<T>;
	onWheel?: WheelEventHandler<T>;
	onWheelCapture?: WheelEventHandler<T>;
	onAnimationStart?: AnimationEventHandler<T>;
	onAnimationStartCapture?: AnimationEventHandler<T>;
	onAnimationEnd?: AnimationEventHandler<T>;
	onAnimationEndCapture?: AnimationEventHandler<T>;
	onAnimationIteration?: AnimationEventHandler<T>;
	onAnimationIterationCapture?: AnimationEventHandler<T>;
	onTransitionEnd?: TransitionEventHandler<T>;
	onTransitionEndCapture?: TransitionEventHandler<T>;
}
type FormEvent = Event;
type ChangeEvent = Event;
export type EventHandler<E extends Event = Event, T = Element> = (event: AlienEvent<E, Extract<T, Element>>) => void;
export type ClipboardEventHandler<T = Element> = EventHandler<ClipboardEvent, T>;
export type CompositionEventHandler<T = Element> = EventHandler<CompositionEvent, T>;
export type DragEventHandler<T = Element> = EventHandler<DragEvent, T>;
export type FocusEventHandler<T = Element> = EventHandler<FocusEvent, T>;
export type FormEventHandler<T = Element> = EventHandler<FormEvent, T>;
export type ChangeEventHandler<T = Element> = EventHandler<ChangeEvent, T>;
export type KeyboardEventHandler<T = Element> = EventHandler<KeyboardEvent, T>;
export type MouseEventHandler<T = Element> = EventHandler<MouseEvent, T>;
export type TouchEventHandler<T = Element> = EventHandler<TouchEvent, T>;
export type PointerEventHandler<T = Element> = EventHandler<PointerEvent, T>;
export type UIEventHandler<T = Element> = EventHandler<UIEvent, T>;
export type WheelEventHandler<T = Element> = EventHandler<WheelEvent, T>;
export type AnimationEventHandler<T = Element> = EventHandler<AnimationEvent, T>;
export type TransitionEventHandler<T = Element> = EventHandler<TransitionEvent, T>;
export type HTMLClassArrayAttribute = readonly HTMLClassAttribute[];
export type HTMLClassObjectAttribute = {
	[key: string]: boolean;
};
export type HTMLClassPrimitiveAttribute = string | DOMTokenList | false | null | undefined;
export type HTMLClassAttribute = HTMLClassArrayAttribute | HTMLClassObjectAttribute | HTMLClassPrimitiveAttribute;
export type HTMLStyleArrayAttribute = readonly HTMLStyleAttribute[];
export type HTMLStyleAttribute = HTMLStyleArrayAttribute | CSSAttributes | false | null | undefined;
type HTMLDatasetData = {
	toString(): string;
} | string | number | boolean | null | undefined;
export type HTMLDatasetAttribute = Record<string, HTMLDatasetData>;
export interface HTMLAttributes<T> extends AriaAttributes, DOMAttributes<T> {
	namespaceURI?: string;
	class?: HTMLClassAttribute;
	dataset?: HTMLDatasetAttribute;
	innerHTML?: string;
	innerText?: string;
	textContent?: string;
	accessKey?: string;
	contentEditable?: Booleanish | "inherit";
	contextMenu?: string;
	dir?: string;
	draggable?: Booleanish;
	hidden?: boolean;
	id?: string;
	lang?: string;
	placeholder?: string;
	slot?: string;
	spellCheck?: Booleanish;
	style?: HTMLStyleAttribute;
	tabIndex?: number;
	title?: string;
	translate?: "yes" | "no";
	radioGroup?: string;
	role?: AriaRole;
	about?: string;
	datatype?: string;
	inlist?: any;
	prefix?: string;
	property?: string;
	resource?: string;
	typeof?: string;
	vocab?: string;
	autoCapitalize?: string;
	autoCorrect?: string;
	autoSave?: string;
	color?: string;
	itemProp?: string;
	itemScope?: boolean;
	itemType?: string;
	itemID?: string;
	itemRef?: string;
	results?: number;
	security?: string;
	unselectable?: "on" | "off";
	/**
	 * Hints at the type of data that might be entered by the user while editing the element or its contents
	 * @see https://html.spec.whatwg.org/multipage/interaction.html#input-modalities:-the-inputmode-attribute
	 */
	inputMode?: "none" | "text" | "tel" | "url" | "email" | "numeric" | "decimal" | "search";
	/**
	 * Specify that a standard HTML element should behave like a defined custom built-in element
	 * @see https://html.spec.whatwg.org/multipage/custom-elements.html#attr-is
	 */
	is?: string;
}
type HTMLReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "origin" | "origin-when-cross-origin" | "same-origin" | "strict-origin" | "strict-origin-when-cross-origin" | "unsafe-url";
type HTMLAnchorTarget = "_self" | "_blank" | "_parent" | "_top" | (string & {});
interface HTMLAnchorAttributes<T> extends HTMLAttributes<T> {
	download?: string;
	href?: string;
	hrefLang?: string;
	media?: string;
	ping?: string;
	rel?: string;
	target?: HTMLAnchorTarget;
	type?: string;
	referrerPolicy?: HTMLReferrerPolicy;
}
interface HTMLAudioAttributes<T> extends HTMLMediaAttributes<T> {
}
interface HTMLAreaAttributes<T> extends HTMLAttributes<T> {
	alt?: string;
	coords?: string;
	href?: string;
	hrefLang?: string;
	media?: string;
	referrerPolicy?: HTMLReferrerPolicy;
	rel?: string;
	shape?: string;
	target?: string;
}
interface HTMLBaseAttributes<T> extends HTMLAttributes<T> {
	href?: string;
	target?: string;
}
interface HTMLBlockquoteAttributes<T> extends HTMLAttributes<T> {
	cite?: string;
}
type HTMLButtonType = "submit" | "reset" | "button";
interface HTMLButtonAttributes<T> extends HTMLAttributes<T> {
	autoFocus?: boolean;
	disabled?: boolean;
	form?: string;
	formAction?: string;
	formEncType?: string;
	formMethod?: string;
	formNoValidate?: boolean;
	formTarget?: string;
	name?: string;
	type?: HTMLButtonType;
	value?: string | number;
}
interface HTMLCanvasAttributes<T> extends HTMLAttributes<T> {
	height?: number | string;
	width?: number | string;
}
interface HTMLColAttributes<T> extends HTMLAttributes<T> {
	span?: number;
	width?: number | string;
}
interface HTMLColgroupAttributes<T> extends HTMLAttributes<T> {
	span?: number;
}
interface HTMLDataAttributes<T> extends HTMLAttributes<T> {
	value?: string | number;
}
interface HTMLDetailsAttributes<T> extends HTMLAttributes<T> {
	open?: boolean;
	onToggle?: EventHandler<Event, T>;
}
interface HTMLDelAttributes<T> extends HTMLAttributes<T> {
	cite?: string;
	dateTime?: string;
}
interface HTMLDialogAttributes<T> extends HTMLAttributes<T> {
	open?: boolean;
}
interface HTMLEmbedAttributes<T> extends HTMLAttributes<T> {
	height?: number | string;
	src?: string;
	type?: string;
	width?: number | string;
}
interface HTMLFieldsetAttributes<T> extends HTMLAttributes<T> {
	disabled?: boolean;
	form?: string;
	name?: string;
}
interface HTMLFormAttributes<T> extends HTMLAttributes<T> {
	acceptCharset?: string;
	action?: string;
	autoComplete?: string;
	encType?: string;
	method?: string;
	name?: string;
	noValidate?: boolean;
	target?: string;
}
interface HTMLHtmlAttributes<T> extends HTMLAttributes<T> {
	manifest?: string;
}
interface HTMLIframeAttributes<T> extends HTMLAttributes<T> {
	allow?: string;
	allowFullScreen?: boolean;
	allowTransparency?: boolean;
	/** @deprecated */
	frameBorder?: number | string;
	height?: number | string;
	loading?: "eager" | "lazy";
	/** @deprecated */
	marginHeight?: number;
	/** @deprecated */
	marginWidth?: number;
	name?: string;
	referrerPolicy?: HTMLReferrerPolicy;
	sandbox?: string;
	/** @deprecated */
	scrolling?: string;
	seamless?: boolean;
	src?: string;
	srcDoc?: string;
	width?: number | string;
}
type HTMLImageCrossOrigin = "anonymous" | "use-credentials" | "";
type HTMLImageDecoding = "async" | "auto" | "sync";
type HTMLImageLoading = "eager" | "lazy";
interface HTMLImgAttributes<T> extends HTMLAttributes<T> {
	alt?: string;
	crossOrigin?: HTMLImageCrossOrigin;
	decoding?: HTMLImageDecoding;
	height?: number | string;
	loading?: HTMLImageLoading;
	referrerPolicy?: HTMLReferrerPolicy;
	sizes?: string;
	src?: string;
	srcSet?: string;
	useMap?: string;
	width?: number | string;
}
interface HTMLInsAttributes<T> extends HTMLAttributes<T> {
	cite?: string;
	dateTime?: string;
}
type HTMLInputEnterKeyHint = "enter" | "done" | "go" | "next" | "previous" | "search" | "send";
interface HTMLInputAttributes<T> extends HTMLAttributes<T> {
	accept?: string;
	alt?: string;
	autoComplete?: string;
	autoFocus?: boolean;
	/** @see https://www.w3.org/TR/html-media-capture/#the-capture-attribute */
	capture?: boolean | string;
	checked?: boolean;
	crossOrigin?: string;
	disabled?: boolean;
	enterKeyHint?: HTMLInputEnterKeyHint;
	form?: string;
	formAction?: string;
	formEncType?: string;
	formMethod?: string;
	formNoValidate?: boolean;
	formTarget?: string;
	height?: number | string;
	list?: string;
	max?: number | string;
	maxLength?: number;
	min?: number | string;
	minLength?: number;
	multiple?: boolean;
	name?: string;
	pattern?: string;
	placeholder?: string;
	readOnly?: boolean;
	required?: boolean;
	size?: number;
	src?: string;
	step?: number | string;
	type?: string;
	value?: string | readonly string[] | number;
	width?: number | string;
	onChange?: ChangeEventHandler<T>;
}
interface HTMLKeygenAttributes<T> extends HTMLAttributes<T> {
	autoFocus?: boolean;
	challenge?: string;
	disabled?: boolean;
	form?: string;
	keyType?: string;
	keyParams?: string;
	name?: string;
}
interface HTMLLabelAttributes<T> extends HTMLAttributes<T> {
	form?: string;
	htmlFor?: string;
}
interface HTMLLiAttributes<T> extends HTMLAttributes<T> {
	value?: number;
}
interface HTMLLinkAttributes<T> extends HTMLAttributes<T> {
	as?: string;
	crossOrigin?: string;
	href?: string;
	hrefLang?: string;
	integrity?: string;
	media?: string;
	referrerPolicy?: HTMLReferrerPolicy;
	rel?: string;
	sizes?: string;
	type?: string;
	charSet?: string;
}
interface HTMLMapAttributes<T> extends HTMLAttributes<T> {
	name?: string;
}
interface HTMLMenuAttributes<T> extends HTMLAttributes<T> {
	type?: string;
}
interface HTMLMediaAttributes<T> extends HTMLAttributes<T> {
	autoPlay?: boolean;
	controls?: boolean;
	controlsList?: string;
	crossOrigin?: string;
	loop?: boolean;
	mediaGroup?: string;
	muted?: boolean;
	playsInline?: boolean;
	preload?: string;
	src?: string;
}
interface HTMLMetaAttributes<T> extends HTMLAttributes<T> {
	charSet?: string;
	content?: string;
	httpEquiv?: string;
	name?: string;
	media?: string;
}
interface HTMLMeterAttributes<T> extends HTMLAttributes<T> {
	form?: string;
	high?: number;
	low?: number;
	max?: number | string;
	min?: number | string;
	optimum?: number;
	value?: number;
}
interface HTMLQuoteAttributes<T> extends HTMLAttributes<T> {
	cite?: string;
}
interface HTMLObjectAttributes<T> extends HTMLAttributes<T> {
	classID?: string;
	data?: string;
	form?: string;
	height?: number | string;
	name?: string;
	type?: string;
	useMap?: string;
	width?: number | string;
	wmode?: string;
}
interface HTMLOlAttributes<T> extends HTMLAttributes<T> {
	reversed?: boolean;
	start?: number;
	type?: "1" | "a" | "A" | "i" | "I";
}
interface HTMLOptgroupAttributes<T> extends HTMLAttributes<T> {
	disabled?: boolean;
	label?: string;
}
interface HTMLOptionAttributes<T> extends HTMLAttributes<T> {
	disabled?: boolean;
	label?: string;
	selected?: boolean;
	value?: string | number;
}
interface HTMLOutputAttributes<T> extends HTMLAttributes<T> {
	form?: string;
	htmlFor?: string;
	name?: string;
}
interface HTMLParamAttributes<T> extends HTMLAttributes<T> {
	name?: string;
	value?: string | readonly string[] | number;
}
interface HTMLProgressAttributes<T> extends HTMLAttributes<T> {
	max?: number | string;
	value?: number;
}
interface HTMLScriptAttributes<T> extends HTMLAttributes<T> {
	async?: boolean;
	/** @deprecated */
	charSet?: string;
	crossOrigin?: string;
	defer?: boolean;
	integrity?: string;
	noModule?: boolean;
	nonce?: string;
	referrerPolicy?: HTMLReferrerPolicy;
	src?: string;
	type?: string;
}
interface HTMLSelectAttributes<T> extends HTMLAttributes<T> {
	autoComplete?: string;
	autoFocus?: boolean;
	disabled?: boolean;
	form?: string;
	multiple?: boolean;
	name?: string;
	required?: boolean;
	size?: number;
	value?: string | readonly string[] | number;
	onChange?: ChangeEventHandler<T>;
}
interface HTMLSlotAttributes<T> extends HTMLAttributes<T> {
	name?: string;
}
interface HTMLSourceAttributes<T> extends HTMLAttributes<T> {
	height?: number | string;
	media?: string;
	sizes?: string;
	src?: string;
	srcSet?: string;
	type?: string;
	width?: number | string;
}
interface HTMLStyleAttributes<T> extends HTMLAttributes<T> {
	media?: string;
	nonce?: string;
	scoped?: boolean;
	type?: string;
}
interface HTMLTableAttributes<T> extends HTMLAttributes<T> {
	cellPadding?: number | string;
	cellSpacing?: number | string;
	summary?: string;
	width?: number | string;
}
interface HTMLTextareaAttributes<T> extends HTMLAttributes<T> {
	autoComplete?: string;
	autoFocus?: boolean;
	cols?: number;
	dirName?: string;
	disabled?: boolean;
	form?: string;
	maxLength?: number;
	minLength?: number;
	name?: string;
	placeholder?: string;
	readOnly?: boolean;
	required?: boolean;
	rows?: number;
	value?: string | number;
	wrap?: string;
	onChange?: ChangeEventHandler<T>;
}
type HTMLTableAlign = "left" | "center" | "right" | "justify" | "char";
type HTMLTableVAlign = "top" | "middle" | "bottom" | "baseline";
interface HTMLTdAttributes<T> extends HTMLAttributes<T> {
	align?: HTMLTableAlign;
	colSpan?: number;
	headers?: string;
	rowSpan?: number;
	scope?: string;
	abbr?: string;
	height?: number | string;
	width?: number | string;
	valign?: HTMLTableVAlign;
}
interface HTMLThAttributes<T> extends HTMLAttributes<T> {
	align?: HTMLTableAlign;
	colSpan?: number;
	headers?: string;
	rowSpan?: number;
	scope?: string;
	abbr?: string;
}
interface HTMLTimeAttributes<T> extends HTMLAttributes<T> {
	dateTime?: string;
}
interface HTMLTrackAttributes<T> extends HTMLAttributes<T> {
	default?: boolean;
	kind?: string;
	label?: string;
	src?: string;
	srcLang?: string;
}
interface HTMLVideoAttributes<T> extends HTMLMediaAttributes<T> {
	height?: number | string;
	playsInline?: boolean;
	poster?: string;
	width?: number | string;
	disablePictureInPicture?: boolean;
	disableRemotePlayback?: boolean;
}
interface HTMLWebViewAttributes<T> extends HTMLAttributes<T> {
	allowFullScreen?: boolean;
	allowpopups?: boolean;
	autoFocus?: boolean;
	autosize?: boolean;
	blinkfeatures?: string;
	disableblinkfeatures?: string;
	disableguestresize?: boolean;
	disablewebsecurity?: boolean;
	guestinstance?: string;
	httpreferrer?: string;
	nodeintegration?: boolean;
	partition?: string;
	plugins?: boolean;
	preload?: string;
	src?: string;
	useragent?: string;
	webpreferences?: string;
}
export type HTMLTagName = keyof HTMLAttributesByTagName;
export interface HTMLAttributesByTagName {
	a: HTMLAnchorAttributes<HTMLAnchorElement>;
	abbr: HTMLAttributes<HTMLElement>;
	address: HTMLAttributes<HTMLElement>;
	area: HTMLAreaAttributes<HTMLAreaElement>;
	article: HTMLAttributes<HTMLElement>;
	aside: HTMLAttributes<HTMLElement>;
	audio: HTMLAudioAttributes<HTMLAudioElement>;
	b: HTMLAttributes<HTMLElement>;
	base: HTMLBaseAttributes<HTMLBaseElement>;
	bdi: HTMLAttributes<HTMLElement>;
	bdo: HTMLAttributes<HTMLElement>;
	big: HTMLAttributes<HTMLElement>;
	blockquote: HTMLBlockquoteAttributes<HTMLElement>;
	body: HTMLAttributes<HTMLBodyElement>;
	br: HTMLAttributes<HTMLBRElement>;
	button: HTMLButtonAttributes<HTMLButtonElement>;
	canvas: HTMLCanvasAttributes<HTMLCanvasElement>;
	caption: HTMLAttributes<HTMLElement>;
	cite: HTMLAttributes<HTMLElement>;
	code: HTMLAttributes<HTMLElement>;
	col: HTMLColAttributes<HTMLTableColElement>;
	colgroup: HTMLColgroupAttributes<HTMLTableColElement>;
	data: HTMLDataAttributes<HTMLDataElement>;
	datalist: HTMLAttributes<HTMLDataListElement>;
	dd: HTMLAttributes<HTMLElement>;
	del: HTMLDelAttributes<HTMLElement>;
	details: HTMLDetailsAttributes<HTMLElement>;
	dfn: HTMLAttributes<HTMLElement>;
	dialog: HTMLDialogAttributes<HTMLDialogElement>;
	div: HTMLAttributes<HTMLDivElement>;
	dl: HTMLAttributes<HTMLDListElement>;
	dt: HTMLAttributes<HTMLElement>;
	em: HTMLAttributes<HTMLElement>;
	embed: HTMLEmbedAttributes<HTMLEmbedElement>;
	fieldset: HTMLFieldsetAttributes<HTMLFieldSetElement>;
	figcaption: HTMLAttributes<HTMLElement>;
	figure: HTMLAttributes<HTMLElement>;
	footer: HTMLAttributes<HTMLElement>;
	form: HTMLFormAttributes<HTMLFormElement>;
	h1: HTMLAttributes<HTMLHeadingElement>;
	h2: HTMLAttributes<HTMLHeadingElement>;
	h3: HTMLAttributes<HTMLHeadingElement>;
	h4: HTMLAttributes<HTMLHeadingElement>;
	h5: HTMLAttributes<HTMLHeadingElement>;
	h6: HTMLAttributes<HTMLHeadingElement>;
	head: HTMLAttributes<HTMLHeadElement>;
	header: HTMLAttributes<HTMLElement>;
	hgroup: HTMLAttributes<HTMLElement>;
	hr: HTMLAttributes<HTMLHRElement>;
	html: HTMLHtmlAttributes<HTMLHtmlElement>;
	i: HTMLAttributes<HTMLElement>;
	iframe: HTMLIframeAttributes<HTMLIFrameElement>;
	img: HTMLImgAttributes<HTMLImageElement>;
	input: HTMLInputAttributes<HTMLInputElement>;
	ins: HTMLInsAttributes<HTMLModElement>;
	kbd: HTMLAttributes<HTMLElement>;
	keygen: HTMLKeygenAttributes<HTMLElement>;
	label: HTMLLabelAttributes<HTMLLabelElement>;
	legend: HTMLAttributes<HTMLLegendElement>;
	li: HTMLLiAttributes<HTMLLIElement>;
	link: HTMLLinkAttributes<HTMLLinkElement>;
	main: HTMLAttributes<HTMLElement>;
	map: HTMLMapAttributes<HTMLMapElement>;
	mark: HTMLAttributes<HTMLElement>;
	menu: HTMLMenuAttributes<HTMLElement>;
	menuitem: HTMLAttributes<HTMLElement>;
	meta: HTMLMetaAttributes<HTMLMetaElement>;
	meter: HTMLMeterAttributes<HTMLElement>;
	nav: HTMLAttributes<HTMLElement>;
	noindex: HTMLAttributes<HTMLElement>;
	noscript: HTMLAttributes<HTMLElement>;
	object: HTMLObjectAttributes<HTMLObjectElement>;
	ol: HTMLOlAttributes<HTMLOListElement>;
	optgroup: HTMLOptgroupAttributes<HTMLOptGroupElement>;
	option: HTMLOptionAttributes<HTMLOptionElement>;
	output: HTMLOutputAttributes<HTMLElement>;
	p: HTMLAttributes<HTMLParagraphElement>;
	param: HTMLParamAttributes<HTMLParamElement>;
	picture: HTMLAttributes<HTMLElement>;
	pre: HTMLAttributes<HTMLPreElement>;
	progress: HTMLProgressAttributes<HTMLProgressElement>;
	q: HTMLQuoteAttributes<HTMLQuoteElement>;
	rp: HTMLAttributes<HTMLElement>;
	rt: HTMLAttributes<HTMLElement>;
	ruby: HTMLAttributes<HTMLElement>;
	s: HTMLAttributes<HTMLElement>;
	samp: HTMLAttributes<HTMLElement>;
	script: HTMLScriptAttributes<HTMLScriptElement>;
	section: HTMLAttributes<HTMLElement>;
	select: HTMLSelectAttributes<HTMLSelectElement>;
	slot: HTMLSlotAttributes<HTMLSlotElement>;
	small: HTMLAttributes<HTMLElement>;
	source: HTMLSourceAttributes<HTMLSourceElement>;
	span: HTMLAttributes<HTMLSpanElement>;
	strong: HTMLAttributes<HTMLElement>;
	style: HTMLStyleAttributes<HTMLStyleElement>;
	sub: HTMLAttributes<HTMLElement>;
	summary: HTMLAttributes<HTMLElement>;
	sup: HTMLAttributes<HTMLElement>;
	table: HTMLTableAttributes<HTMLTableElement>;
	template: HTMLAttributes<HTMLTemplateElement>;
	tbody: HTMLAttributes<HTMLTableSectionElement>;
	td: HTMLTdAttributes<HTMLTableDataCellElement>;
	textarea: HTMLTextareaAttributes<HTMLTextAreaElement>;
	tfoot: HTMLAttributes<HTMLTableSectionElement>;
	th: HTMLThAttributes<HTMLTableHeaderCellElement>;
	thead: HTMLAttributes<HTMLTableSectionElement>;
	time: HTMLTimeAttributes<HTMLElement>;
	title: HTMLAttributes<HTMLTitleElement>;
	tr: HTMLAttributes<HTMLTableRowElement>;
	track: HTMLTrackAttributes<HTMLTrackElement>;
	u: HTMLAttributes<HTMLElement>;
	ul: HTMLAttributes<HTMLUListElement>;
	var: HTMLAttributes<HTMLElement>;
	video: HTMLVideoAttributes<HTMLVideoElement>;
	wbr: HTMLAttributes<HTMLElement>;
	webview: HTMLWebViewAttributes<HTMLElement>;
}
export declare namespace HTML {
	type Anchor = HTMLAnchorElement;
	type Area = HTMLAreaElement;
	type Audio = HTMLAudioElement;
	type Base = HTMLBaseElement;
	type Body = HTMLBodyElement;
	type BR = HTMLBRElement;
	type Button = HTMLButtonElement;
	type Canvas = HTMLCanvasElement;
	type Data = HTMLDataElement;
	type DataList = HTMLDataListElement;
	type Details = HTMLDetailsElement;
	type Dialog = HTMLDialogElement;
	type Directory = HTMLDirectoryElement;
	type Div = HTMLDivElement;
	type DList = HTMLDListElement;
	type Embed = HTMLEmbedElement;
	type FieldSet = HTMLFieldSetElement;
	type Font = HTMLFontElement;
	type Form = HTMLFormElement;
	type Frame = HTMLFrameElement;
	type FrameSet = HTMLFrameSetElement;
	type Head = HTMLHeadElement;
	type Heading = HTMLHeadingElement;
	type HR = HTMLHRElement;
	type HtmlElement = HTMLHtmlElement;
	type IFrame = HTMLIFrameElement;
	type Image = HTMLImageElement;
	type Input = HTMLInputElement;
	type Label = HTMLLabelElement;
	type Legend = HTMLLegendElement;
	type LI = HTMLLIElement;
	type Link = HTMLLinkElement;
	type Map = HTMLMapElement;
	type Marquee = HTMLMarqueeElement;
	type MediaElement = HTMLMediaElement;
	type Menu = HTMLMenuElement;
	type Meta = HTMLMetaElement;
	type Meter = HTMLMeterElement;
	type Mod = HTMLModElement;
	type Object = HTMLObjectElement;
	type OList = HTMLOListElement;
	type OptGroup = HTMLOptGroupElement;
	type Option = HTMLOptionElement;
	type Output = HTMLOutputElement;
	type Paragraph = HTMLParagraphElement;
	type Param = HTMLParamElement;
	type Picture = HTMLPictureElement;
	type Pre = HTMLPreElement;
	type Progress = HTMLProgressElement;
	type Quote = HTMLQuoteElement;
	type Script = HTMLScriptElement;
	type Select = HTMLSelectElement;
	type Slot = HTMLSlotElement;
	type Source = HTMLSourceElement;
	type Span = HTMLSpanElement;
	type Style = HTMLStyleElement;
	type Table = HTMLTableElement;
	type TableCaption = HTMLTableCaptionElement;
	type TableCell = HTMLTableCellElement;
	type TableCol = HTMLTableColElement;
	type TableDataCell = HTMLTableDataCellElement;
	type TableHeaderCell = HTMLTableHeaderCellElement;
	type TableRow = HTMLTableRowElement;
	type TableSection = HTMLTableSectionElement;
	type Template = HTMLTemplateElement;
	type TextArea = HTMLTextAreaElement;
	type Time = HTMLTimeElement;
	type Title = HTMLTitleElement;
	type Track = HTMLTrackElement;
	type UList = HTMLUListElement;
	type Unknown = HTMLUnknownElement;
	type Video = HTMLVideoElement;
}
export interface SVGAttributes<T> extends AriaAttributes, DOMAttributes<T> {
	color?: string;
	height?: number | string;
	id?: string;
	lang?: string;
	max?: number | string;
	media?: string;
	method?: string;
	min?: number | string;
	name?: string;
	target?: string;
	type?: string;
	width?: number | string;
	role?: AriaRole;
	tabIndex?: number;
	crossOrigin?: "anonymous" | "use-credentials" | "";
	accentHeight?: number | string;
	accumulate?: "none" | "sum";
	additive?: "replace" | "sum";
	alignmentBaseline?: "auto" | "baseline" | "before-edge" | "text-before-edge" | "middle" | "central" | "after-edge" | "text-after-edge" | "ideographic" | "alphabetic" | "hanging" | "mathematical" | "inherit";
	allowReorder?: "no" | "yes";
	alphabetic?: number | string;
	amplitude?: number | string;
	arabicForm?: "initial" | "medial" | "terminal" | "isolated";
	ascent?: number | string;
	attributeName?: string;
	attributeType?: string;
	autoReverse?: Booleanish;
	azimuth?: number | string;
	baseFrequency?: number | string;
	baselineShift?: number | string;
	baseProfile?: number | string;
	bbox?: number | string;
	begin?: number | string;
	bias?: number | string;
	by?: number | string;
	calcMode?: number | string;
	capHeight?: number | string;
	clip?: number | string;
	clipPath?: string;
	clipPathUnits?: number | string;
	clipRule?: number | string;
	colorInterpolation?: number | string;
	colorInterpolationFilters?: "auto" | "sRGB" | "linearRGB" | "inherit";
	colorProfile?: number | string;
	colorRendering?: number | string;
	contentScriptType?: number | string;
	contentStyleType?: number | string;
	cursor?: number | string;
	cx?: number | string;
	cy?: number | string;
	d?: string;
	decelerate?: number | string;
	descent?: number | string;
	diffuseConstant?: number | string;
	direction?: number | string;
	display?: number | string;
	divisor?: number | string;
	dominantBaseline?: number | string;
	dur?: number | string;
	dx?: number | string;
	dy?: number | string;
	edgeMode?: number | string;
	elevation?: number | string;
	enableBackground?: number | string;
	end?: number | string;
	exponent?: number | string;
	externalResourcesRequired?: Booleanish;
	fill?: string;
	fillOpacity?: number | string;
	fillRule?: "nonzero" | "evenodd" | "inherit";
	filter?: string;
	filterRes?: number | string;
	filterUnits?: number | string;
	floodColor?: number | string;
	floodOpacity?: number | string;
	focusable?: Booleanish | "auto";
	fontFamily?: string;
	fontSize?: number | string;
	fontSizeAdjust?: number | string;
	fontStretch?: number | string;
	fontStyle?: number | string;
	fontVariant?: number | string;
	fontWeight?: number | string;
	format?: number | string;
	from?: number | string;
	fx?: number | string;
	fy?: number | string;
	g1?: number | string;
	g2?: number | string;
	glyphName?: number | string;
	glyphOrientationHorizontal?: number | string;
	glyphOrientationVertical?: number | string;
	glyphRef?: number | string;
	gradientTransform?: string;
	gradientUnits?: string;
	hanging?: number | string;
	horizAdvX?: number | string;
	horizOriginX?: number | string;
	href?: string;
	ideographic?: number | string;
	imageRendering?: number | string;
	in2?: number | string;
	in?: string;
	intercept?: number | string;
	k1?: number | string;
	k2?: number | string;
	k3?: number | string;
	k4?: number | string;
	k?: number | string;
	kernelMatrix?: number | string;
	kernelUnitLength?: number | string;
	kerning?: number | string;
	keyPoints?: number | string;
	keySplines?: number | string;
	keyTimes?: number | string;
	lengthAdjust?: number | string;
	letterSpacing?: number | string;
	lightingColor?: number | string;
	limitingConeAngle?: number | string;
	local?: number | string;
	markerEnd?: string;
	markerHeight?: number | string;
	markerMid?: string;
	markerStart?: string;
	markerUnits?: number | string;
	markerWidth?: number | string;
	mask?: string;
	maskContentUnits?: number | string;
	maskUnits?: number | string;
	mathematical?: number | string;
	mode?: number | string;
	numOctaves?: number | string;
	offset?: number | string;
	opacity?: number | string;
	operator?: number | string;
	order?: number | string;
	orient?: number | string;
	orientation?: number | string;
	origin?: number | string;
	overflow?: number | string;
	overlinePosition?: number | string;
	overlineThickness?: number | string;
	paintOrder?: number | string;
	panose1?: number | string;
	path?: string;
	pathLength?: number | string;
	patternContentUnits?: string;
	patternTransform?: number | string;
	patternUnits?: string;
	pointerEvents?: number | string;
	points?: string;
	pointsAtX?: number | string;
	pointsAtY?: number | string;
	pointsAtZ?: number | string;
	preserveAlpha?: Booleanish;
	preserveAspectRatio?: string;
	primitiveUnits?: number | string;
	r?: number | string;
	radius?: number | string;
	refX?: number | string;
	refY?: number | string;
	renderingIntent?: number | string;
	repeatCount?: number | string;
	repeatDur?: number | string;
	requiredExtensions?: number | string;
	requiredFeatures?: number | string;
	restart?: number | string;
	result?: string;
	rotate?: number | string;
	rx?: number | string;
	ry?: number | string;
	scale?: number | string;
	seed?: number | string;
	shapeRendering?: number | string;
	slope?: number | string;
	spacing?: number | string;
	specularConstant?: number | string;
	specularExponent?: number | string;
	speed?: number | string;
	spreadMethod?: string;
	startOffset?: number | string;
	stdDeviation?: number | string;
	stemh?: number | string;
	stemv?: number | string;
	stitchTiles?: number | string;
	stopColor?: string;
	stopOpacity?: number | string;
	strikethroughPosition?: number | string;
	strikethroughThickness?: number | string;
	string?: number | string;
	stroke?: string;
	strokeDasharray?: string | number;
	strokeDashoffset?: string | number;
	strokeLinecap?: "butt" | "round" | "square" | "inherit";
	strokeLinejoin?: "miter" | "round" | "bevel" | "inherit";
	strokeMiterlimit?: number | string;
	strokeOpacity?: number | string;
	strokeWidth?: number | string;
	surfaceScale?: number | string;
	systemLanguage?: number | string;
	tableValues?: number | string;
	targetX?: number | string;
	targetY?: number | string;
	textAnchor?: string;
	textDecoration?: number | string;
	textLength?: number | string;
	textRendering?: number | string;
	to?: number | string;
	transform?: string;
	u1?: number | string;
	u2?: number | string;
	underlinePosition?: number | string;
	underlineThickness?: number | string;
	unicode?: number | string;
	unicodeBidi?: number | string;
	unicodeRange?: number | string;
	unitsPerEm?: number | string;
	vAlphabetic?: number | string;
	values?: string;
	vectorEffect?: number | string;
	version?: string;
	vertAdvY?: number | string;
	vertOriginX?: number | string;
	vertOriginY?: number | string;
	vHanging?: number | string;
	vIdeographic?: number | string;
	viewBox?: string;
	viewTarget?: number | string;
	visibility?: number | string;
	vMathematical?: number | string;
	widths?: number | string;
	wordSpacing?: number | string;
	writingMode?: number | string;
	x1?: number | string;
	x2?: number | string;
	x?: number | string;
	xChannelSelector?: string;
	xHeight?: number | string;
	xlinkActuate?: string;
	xlinkArcrole?: string;
	xlinkHref?: string;
	xlinkRole?: string;
	xlinkShow?: string;
	xlinkTitle?: string;
	xlinkType?: string;
	xmlBase?: string;
	xmlLang?: string;
	xmlns?: string;
	xmlnsXlink?: string;
	xmlSpace?: string;
	y1?: number | string;
	y2?: number | string;
	y?: number | string;
	yChannelSelector?: string;
	z?: number | string;
	zoomAndPan?: string;
}
/**
 * Some SVGElement interfaces are not assignable to SVGElement, but are still
 * technically SVG elements.
 */
export type SVGElementLike = SVGElement | SVGFEDisplacementMapElement | SVGFEDistantLightElement | SVGFEFuncAElement | SVGFEFuncBElement | SVGFEFuncGElement | SVGFEFuncRElement | SVGStopElement | SVGTextElement | SVGTSpanElement;
export type SVGTagName = keyof SVGAttributesByTagName;
export interface SVGAttributesByTagName {
	svg: SVGAttributes<SVGSVGElement> & HTMLAttributes<SVGSVGElement>;
	animate: SVGAttributes<SVGAnimateElement>;
	animateMotion: SVGAttributes<SVGAnimateMotionElement>;
	animateTransform: SVGAttributes<SVGAnimateTransformElement>;
	circle: SVGAttributes<SVGCircleElement>;
	clipPath: SVGAttributes<SVGClipPathElement>;
	defs: SVGAttributes<SVGDefsElement>;
	desc: SVGAttributes<SVGDescElement>;
	ellipse: SVGAttributes<SVGEllipseElement>;
	feBlend: SVGAttributes<SVGFEBlendElement>;
	feColorMatrix: SVGAttributes<SVGFEColorMatrixElement>;
	feComponentTransfer: SVGAttributes<SVGFEComponentTransferElement>;
	feComposite: SVGAttributes<SVGFECompositeElement>;
	feConvolveMatrix: SVGAttributes<SVGFEConvolveMatrixElement>;
	feDiffuseLighting: SVGAttributes<SVGFEDiffuseLightingElement>;
	feDisplacementMap: SVGAttributes<SVGFEDisplacementMapElement>;
	feDistantLight: SVGAttributes<SVGFEDistantLightElement>;
	feDropShadow: SVGAttributes<SVGFEDropShadowElement>;
	feFlood: SVGAttributes<SVGFEFloodElement>;
	feFuncA: SVGAttributes<SVGFEFuncAElement>;
	feFuncB: SVGAttributes<SVGFEFuncBElement>;
	feFuncG: SVGAttributes<SVGFEFuncGElement>;
	feFuncR: SVGAttributes<SVGFEFuncRElement>;
	feGaussianBlur: SVGAttributes<SVGFEGaussianBlurElement>;
	feImage: SVGAttributes<SVGFEImageElement>;
	feMerge: SVGAttributes<SVGFEMergeElement>;
	feMergeNode: SVGAttributes<SVGFEMergeNodeElement>;
	feMorphology: SVGAttributes<SVGFEMorphologyElement>;
	feOffset: SVGAttributes<SVGFEOffsetElement>;
	fePointLight: SVGAttributes<SVGFEPointLightElement>;
	feSpecularLighting: SVGAttributes<SVGFESpecularLightingElement>;
	feSpotLight: SVGAttributes<SVGFESpotLightElement>;
	feTile: SVGAttributes<SVGFETileElement>;
	feTurbulence: SVGAttributes<SVGFETurbulenceElement>;
	filter: SVGAttributes<SVGFilterElement>;
	foreignObject: SVGAttributes<SVGForeignObjectElement>;
	g: SVGAttributes<SVGGElement>;
	image: SVGAttributes<SVGImageElement>;
	line: SVGAttributes<SVGLineElement>;
	linearGradient: SVGAttributes<SVGLinearGradientElement>;
	marker: SVGAttributes<SVGMarkerElement>;
	mask: SVGAttributes<SVGMaskElement>;
	metadata: SVGAttributes<SVGMetadataElement>;
	mpath: SVGAttributes<SVGMPathElement>;
	path: SVGAttributes<SVGPathElement>;
	pattern: SVGAttributes<SVGPatternElement>;
	polygon: SVGAttributes<SVGPolygonElement>;
	polyline: SVGAttributes<SVGPolylineElement>;
	radialGradient: SVGAttributes<SVGRadialGradientElement>;
	rect: SVGAttributes<SVGRectElement>;
	stop: SVGAttributes<SVGStopElement>;
	switch: SVGAttributes<SVGSwitchElement>;
	symbol: SVGAttributes<SVGSymbolElement>;
	text: SVGAttributes<SVGTextElement>;
	textPath: SVGAttributes<SVGTextPathElement>;
	tspan: SVGAttributes<SVGTSpanElement>;
	use: SVGAttributes<SVGUseElement>;
	view: SVGAttributes<SVGViewElement>;
}
export declare namespace SVG {
	type Anchor = SVGAElement;
	type Animate = SVGAnimateElement;
	type AnimateMotion = SVGAnimateMotionElement;
	type AnimateTransform = SVGAnimateTransformElement;
	type Circle = SVGCircleElement;
	type ClipPath = SVGClipPathElement;
	type Defs = SVGDefsElement;
	type Desc = SVGDescElement;
	type Ellipse = SVGEllipseElement;
	type FEBlend = SVGFEBlendElement;
	type FEColorMatrix = SVGFEColorMatrixElement;
	type FEComponentTransfer = SVGFEComponentTransferElement;
	type FEConvolveMatrix = SVGFEConvolveMatrixElement;
	type FEDiffuseLighting = SVGFEDiffuseLightingElement;
	type FEDisplacementMap = SVGFEDisplacementMapElement;
	type FEDistantLight = SVGFEDistantLightElement;
	type FEDropShadow = SVGFEDropShadowElement;
	type FEFlood = SVGFEFloodElement;
	type FEFuncA = SVGFEFuncAElement;
	type FEFuncB = SVGFEFuncBElement;
	type FEFuncG = SVGFEFuncGElement;
	type FEFuncR = SVGFEFuncRElement;
	type FEGaussianBlur = SVGFEGaussianBlurElement;
	type FEImage = SVGFEImageElement;
	type FEMerge = SVGFEMergeElement;
	type FEMergeNode = SVGFEMergeNodeElement;
	type FEMorphology = SVGFEMorphologyElement;
	type FEOffset = SVGFEOffsetElement;
	type FEPointLight = SVGFEPointLightElement;
	type FETile = SVGFETileElement;
	type FETurbulence = SVGFETurbulenceElement;
	type Filter = SVGFilterElement;
	type Foreign = SVGForeignObjectElement;
	type G = SVGGElement;
	type Gradient = SVGGradientElement;
	type Image = SVGImageElement;
	type Line = SVGLineElement;
	type LinearGradient = SVGLinearGradientElement;
	type Marker = SVGMarkerElement;
	type Mask = SVGMaskElement;
	type Metadata = SVGMetadataElement;
	type Path = SVGPathElement;
	type Pattern = SVGPatternElement;
	type Polygon = SVGPolygonElement;
	type Polyline = SVGPolylineElement;
	type RadialGradient = SVGRadialGradientElement;
	type Rect = SVGRectElement;
	type Script = SVGScriptElement;
	type Stop = SVGStopElement;
	type Style = SVGStyleElement;
	type SVG = SVGSVGElement;
	type Switch = SVGSwitchElement;
	type Symbol = SVGSymbolElement;
	type Text = SVGTextElement;
	type TextPath = SVGTextPathElement;
	type Title = SVGTitleElement;
	type Use = SVGUseElement;
	type View = SVGViewElement;
}
type AlienNode = ShadowRootNode | DeferredHostNode | DeferredCompositeNode;
export interface ShadowRootNode {
	[kAlienNodeType]: typeof kShadowRootNodeType;
	props: ShadowRootInit;
	children: ResolvedChild[];
}
export declare const isShadowRoot: (node: any) => node is ShadowRootNode;
export interface TemplateNode {
	[kAlienNodeType]: typeof kTemplateNodeType;
	template: HTMLOrSVGElement$1;
}
export declare const isTemplateNode: (node: any) => node is TemplateNode;
type HostNodeTag = string | TemplateNode;
interface DeferredNode {
	[kAlienNodeType]: typeof kDeferredNodeType;
	tag: HostNodeTag | FunctionComponent<any>;
	props: any;
	context: ContextMap | undefined;
}
interface DeferredHostNode extends DeferredNode {
	tag: HostNodeTag;
	ref: JSX.RefProp<any>;
	children: DeferredChildren;
	namespaceURI: string | undefined;
}
type DeferredChild = ChildNode | AlienNode;
type DeferredChildren = (DeferredChild | null)[] | ReadonlyRef<JSX.Children> | false | null | undefined;
interface DeferredCompositeNode extends DeferredNode {
	tag: FunctionComponent<any>;
	children?: ResolvedChild[];
	trace: () => void;
}
type AnyDeferredNode = DeferredHostNode | DeferredCompositeNode;
type Thunk<T = any> = () => T;
type Thunkable<T> = T | Thunk<T>;
export declare namespace JSX {
	type Element = HTMLElement;
	type ElementKey = string | number;
	type ElementRef<Element extends AnyElement = AnyElement> = {
		setElement(element: Element | null): void;
	};
	type RefProp<Element extends AnyElement = AnyElement> = readonly (RefProp<Element> | false | null | undefined)[] | ElementRef<Element> | false | null | undefined;
	type Children = ChildNode | DocumentFragment | ChildrenFragment | ArrayLike<Children> | string | number | boolean | null | undefined;
	type ChildrenProp = Thunkable<Children | ReadonlyRef<Children>>;
	/**
	 * This type represents a valid component result (except for null).
	 */
	type ElementLike = ChildNode | AlienNode | DocumentFragment | ChildrenFragment;
	/**
	 * Use this type if your component has a prop that can be a single JSX
	 * element. Your component should call `useChildren` on this prop to get the
	 * materialized DOM node.
	 */
	type ElementProp = Thunkable<ElementLike>;
	/**
	 * Use this type if your component has a prop that can be a single JSX element
	 * or an array of JSX elements. Your component should call `useChildren` on
	 * this prop to get the materialized DOM nodes.
	 */
	type ElementsProp = Thunkable<ElementLike | ElementLike[]>;
	type ElementType = keyof IntrinsicElements | FunctionComponent<any>;
	type HTMLClassArrayProp = readonly (FlatReadonlyRef<HTMLClassProp> | HTMLClassProp)[];
	type HTMLClassMapProp = {
		[key: string]: boolean | ReadonlyRef<boolean>;
	};
	type HTMLClassProp = HTMLClassArrayProp | HTMLClassMapProp | HTMLClassPrimitiveAttribute extends infer HTMLClassProp ? ReadonlyRef<HTMLClassProp> | HTMLClassProp : never;
	type CSSProps = ObservableProps<CSSAttributes>;
	type HTMLStyleArrayProp = readonly (FlatReadonlyRef<HTMLStyleProp> | HTMLStyleProp)[];
	type HTMLStyleProp = HTMLStyleArrayProp | CSSProps | false | null | undefined extends infer HTMLStyleProp ? ReadonlyRef<HTMLStyleProp> | HTMLStyleProp : never;
	type HTMLDatasetProp = Record<string, HTMLDatasetAttribute[string] | ReadonlyRef<HTMLDatasetAttribute[string]>> extends infer HTMLDatasetProp ? ReadonlyRef<HTMLDatasetProp> | HTMLDatasetProp : never;
	type HTMLProps<T extends keyof HTMLAttributesByTagName> = unknown & HTMLObservableProps<T> & IntrinsicAttributes & {
		ref?: RefProp<Element> | RefProp<HTMLElement>;
		children?: ChildrenProp;
	};
	type SVGProps<T extends keyof SVGAttributesByTagName> = unknown & SVGObservableProps<T> & IntrinsicAttributes & {
		ref?: RefProp<Element> | RefProp<SVGElement>;
		children?: ChildrenProp;
	};
	type ObservableProps<Props extends object> = {
		[K in keyof Props]: ObservableProp<K, Props[K]>;
	};
	/** One of the native HTML or SVG tags. */
	type TagName = HTMLTagName | SVGTagName;
	/**
	 * Infer the tag name of a DOM element.
	 */
	type InferTagName<T extends AnyElement> = HTMLTagName extends any ? HTMLElementTagNameMap[HTMLTagName & keyof HTMLElementTagNameMap] extends T ? HTMLTagName : SVGTagName extends any ? SVGElementTagNameMap[SVGTagName & keyof SVGElementTagNameMap] extends T ? SVGTagName : never : never : never;
	/**
	 * Extract a DOM element type from a JSX element type.
	 */
	type InferDOMElement<T> = T extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[T] : T extends keyof SVGElementTagNameMap ? SVGElementTagNameMap[T] : T extends FunctionComponent ? JSX.Element : never;
	/**
	 * Infer DOM attributes from a DOM element or tag name.
	 */
	type InferAttributes<T> = T extends HTMLTagName ? HTMLAttributesByTagName[T] : T extends SVGTagName ? SVGAttributesByTagName[T] : T extends AnyElement ? [
		HTMLElement
	] extends [
		T
	] ? HTMLAttributes<T> : [
		SVGElement
	] extends [
		T
	] ? SVGAttributes<T> : InferAttributes<InferTagName<T>> : never;
	/**
	 * Infer the JSX props from a JSX element type.
	 */
	type InferProps<T> = T extends FunctionComponent<infer Props> ? Props : T extends HTMLTagName ? HTMLProps<T> : T extends SVGTagName ? SVGProps<T> : never;
	/** @internal Required by TypeScript. It contains the prop types of every valid, host element. */
	type IntrinsicElements = {
		[T in HTMLTagName]: HTMLProps<T>;
	} & {
		[T in SVGTagName]: SVGProps<T>;
	};
	/** @internal Required by TypeScript. It contains attributes usable on any JSX element. */
	interface IntrinsicAttributes {
		key?: ElementKey | null | undefined;
	}
	/**
	 * @internal Required by TypeScript. It contains the type for JSX children.
	 * @see https://www.typescriptlang.org/docs/handbook/jsx.html#children-type-checking
	 */
	interface ElementChildrenAttribute {
		children: ChildrenProp;
	}
}
type HTMLObservableProps<T extends HTMLTagName> = HTMLAttributesByTagName[T] extends infer Props ? {
	[K in keyof Props]: HTMLObservableProp<K, Props[K]>;
} : never;
type HTMLObservableProp<Key extends keyof any, Value> = Key extends `on${string}` ? Value : [
	HTMLClassAttribute | undefined
] extends [
	Value
] ? JSX.HTMLClassProp : [
	HTMLStyleAttribute | undefined
] extends [
	Value
] ? JSX.HTMLStyleProp : [
	HTMLDatasetAttribute | undefined
] extends [
	Value
] ? JSX.HTMLDatasetProp : [
	Value
] extends [
	Record<string, any> | EventHandler | undefined
] ? Value : Value | ReadonlyRef<Value>;
type SVGObservableProps<T extends SVGTagName> = SVGAttributesByTagName[T] extends infer Props extends object ? T extends "svg" ? {
	[K in keyof Props]: HTMLObservableProp<K, Props[K]>;
} : JSX.ObservableProps<Props> : never;
type ObservableProp<Key extends keyof any, Value> = Value | (Key extends "children" | `on${string}` ? never : [
	Value
] extends [
	Record<string, any> | EventHandler | undefined
] ? never : ReadonlyRef<Value>);
export type EffectResult = ((detail?: {
	isHotReload?: boolean;
}) => void) | void;
export type EffectCallback<State = {}> = (context: EffectContext<State>) => EffectResult;
export type EffectContext<State = {}> = State & {
	get isFirstRun(): boolean;
	get rootNode(): JSX.Element | Comment;
	get rootElement(): JSX.Element;
	get parentNode(): JSX.Element;
};
/**
 * Run an effect after the component is mounted. The effect may rerun on a rerender
 * if the dependencies have changed. The effect is disposed before the next run.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useEffect<State = {}>(effect: EffectCallback<State> | Falsy, deps: readonly any[]): void;
/**
 * Useful for hooks that wrap `useEffect`. It takes care of passing along the `EffectContext` to the wrapped effect.
 *
 * 🪝 This hook adds 1 to the hook offset.
 */
export declare function useWrappedEffect(effect: EffectCallback | Falsy, wrapper: (effect: () => EffectResult) => EffectResult, deps: readonly any[]): void;
export type ElementProxy<T extends Element = Element> = T & {
	toElement(): T | null;
	onceElementExists(effect: (element: T) => EffectResult): Disposable$1;
	setElement(element: T | null): void;
};
/** Coerce an `ElementProxy` to its original `Element` type. */
export type FromElementProxy<T> = T extends ElementProxy<infer U> ? U : Extract<T, Element>;
export declare function createElementProxy<T extends Element>(effect?: (element: T) => EffectResult): ElementProxy<T>;
export declare const isElementProxy: {
	<T extends Element>(arg: T): arg is ElementProxy<T>;
	<T extends Element = Element>(arg: any): arg is ElementProxy<T>;
};
type AnyElement = Element;
type AnyEvent = Event;
type HTMLOrSVGElement$1 = HTMLElement | SVGElement;
type VarArgs<T> = T | readonly T[];
type Booleanish = boolean | "true" | "false";
type AlienTag<Element extends AnyElement = HTMLOrSVGElement$1> = Element | (Element extends HTMLElement ? HTMLElement | keyof HTMLElementTagNameMap : never) | SVGElement | keyof SVGElementTagNameMap;
type LooseAccess<T, K> = K extends keyof T ? T[K] : never;
type AlienTagNameMap<Element extends AnyElement> = Element extends any ? SVGElementTagNameMap | ([
	AnyElement
] extends [
	Element
] ? HTMLElementTagNameMap : Element extends HTMLElement ? HTMLElementTagNameMap : never) : never;
type AlienSelect<T extends string | AnyElement, Context extends AnyElement = AnyElement> = T extends string ? AlienTagNameMap<FromElementProxy<Context>> extends infer TagNameMap ? TagNameMap extends any ? Extract<LooseAccess<TagNameMap, T>, Node> : never : never : T;
export declare function $<Element extends AlienTag<HTMLOrSVGElement$1>>(element: AnyElement): AlienSelect<Element>;
export declare function $(element: AnyElement): AlienElement & AnyElement;
export declare function $<Element extends AlienTag<HTMLOrSVGElement$1>>(element: AnyElement | null): AlienSelect<Element> | null;
export declare function $(element: AnyElement | null): (AlienElement & AnyElement) | null;
export declare function $<Element extends AlienTag<HTMLOrSVGElement$1> = HTMLOrSVGElement$1>(selector: string): AlienSelect<Element> | null;
export type AlienSelectable = string | AnyElement | readonly AnyElement[] | NodeListOf<AnyElement> | Iterable<AnyElement>;
export declare const $$: <Element_1 extends AlienTag<HTMLOrSVGElement$1> = HTMLOrSVGElement$1>(...selectors: (AlienSelectable | false | null | undefined)[]) => AlienElementList<AlienSelect<Element_1>>;
export type SpringAnimation<Element extends AnyElement = any, Props extends object = AnimatedProps<Element>> = {
	to?: Props | Falsy;
	from?: Props | Falsy;
	spring?: SpringConfigOption<Props>;
	velocity?: number | {
		[K in keyof Props]?: number;
	};
	delay?: SpringDelay | {
		[K in keyof Props]?: SpringDelay;
	};
	immediate?: boolean | {
		[K in keyof Props]?: boolean;
	};
	dilate?: number;
	anchor?: [
		number,
		number
	];
	onStart?: (target: Element) => void;
	onChange?: FrameCallback<Element, Props>;
	onRest?: FrameCallback<Element, Props>;
};
export type SpringDelay = number | SpringDelayFn | Promise<unknown>;
export type SpringDelayFn = (signal: AbortSignal, key: string) => Promise<unknown> | null | void;
export type FrameCallback<Element extends AnyElement, Props extends object = AnimatedProps<Element>> = (props: [
	Element
] extends [
	Any
] ? any : Required<Props>, target: Element) => void;
export type StepAnimationFn<Element extends AnyElement = any> = (frame: StepAnimation<Element>) => AnimatedProps<Element> | null;
export type StepAnimation<Element extends AnyElement = any> = {
	target: Element;
	/** When true, the animation ends. */
	done: boolean;
	/** When the animation started as a `requestAnimationFrame` timestamp. */
	t0: number;
	/** Milliseconds since the previous frame. */
	dt: number;
	/** Time of the current frame as a `requestAnimationFrame` timestamp. */
	time: number;
	/** Milliseconds since the animation started. */
	duration: number;
	/** An accumulation of frames since the animation started. */
	current: AnimatedProps<Element>;
	/**
	 * If multiple targets exist for the same animation, this is the
	 * target index for the current `target`.
	 */
	index: number;
};
export type SpringConfigOption<Props> = ((key: KeyArgument<Props>) => SpringConfig | Falsy) | SpringConfig | Falsy;
export type SpringConfig = {
	frequency?: number;
	damping?: number;
	tension?: number;
	friction?: number;
	mass?: number;
	bounce?: number;
	clamp?: boolean;
	restVelocity?: number;
};
export interface HTMLAnimatedProps extends CSSTransformAttributes {
	backgroundColor?: string;
	borderRadius?: CSSLength;
	color?: string;
	opacity?: number;
}
export interface SVGAnimatedProps extends CSSTransformAttributes {
	fill?: string;
	fillOpacity?: number;
	stroke?: string;
	strokeWidth?: number;
	strokeOpacity?: number;
	opacity?: number;
	rx?: CSSLength;
	ry?: CSSLength;
	width?: CSSLength;
	height?: CSSLength;
	r?: CSSLength;
	cx?: CSSLength;
	cy?: CSSLength;
}
export type AnimatedProps<T extends AnyElement> = [
	T
] extends [
	Any
] ? any : T extends HTMLElement ? HTMLAnimatedProps : T extends SVGElement ? SVGAnimatedProps : never;
export type AnimatedProp<T extends AnyElement> = string & keyof AnimatedProps<T>;
type KeyArgument<T> = [
	T
] extends [
	Any
] ? any : keyof T;
type OneOrMany<T> = T | readonly T[];
export type AnimationsParam<Element extends AnyElement = any> = OneOrMany<SpringAnimation<Element>> | StepAnimationFn<Element>;
export declare function animate(elements: OneOrMany<HTMLElement> | NodeListOf<HTMLElement>, animations: AnimationsParam<HTMLElement>): void;
export declare function animate(elements: OneOrMany<SVGElement> | NodeListOf<SVGElement>, animations: AnimationsParam<SVGElement>): void;
export declare function animate(selector: AlienSelectable, animations: AnimationsParam<HTMLOrSVGElement$1>): void;
/**
 * Declare a template node, which can be used as a JSX element type. The JSX
 * runtime will use `cloneNode(true)` on the template.
 */
export declare function template<T extends HTMLTagName | SVGTagName>(template: HTMLOrSVGElement$1): FunctionComponent<JSX.InferProps<T>>;
interface NodeStore {
	getNodeForKey: (key: JSX.ElementKey) => ChildNode | DocumentFragment | undefined;
	setNodeForKey: (key: JSX.ElementKey, node: ChildNode | DocumentFragment) => void;
	getNodeUpdateForKey: (key: JSX.ElementKey) => AnyDeferredNode | undefined;
	setNodeUpdateForKey: (key: JSX.ElementKey, update: AnyDeferredNode) => void;
}
type ElementRefs = Map<JSX.ElementKey, ChildNode | DocumentFragment>;
declare class AlienComponent<Props extends object = any> extends Observer implements NodeStore {
	readonly tag: (props: Props) => JSX.ChildrenProp;
	readonly parent: AlienComponent | null;
	readonly context: ContextStore;
	readonly props: Props;
	hooks: any[];
	nextHookIndex: number;
	rootNode: ChildNode | DocumentFragment | null;
	rootNodeCallbacks: Set<(node: ChildNode | DocumentFragment) => void> | null;
	rootKey: JSX.ElementKey | undefined;
	/** Deferred nodes (by key) created in the current render pass. */
	updates: Map<JSX.ElementKey, AnyDeferredNode> | null;
	/** Stable references to the nodes that are mounted. */
	nodes: ElementRefs | null;
	/** Stable references that were added or reused by the current render pass. */
	newNodes: ElementRefs | null;
	/** Effects tied to the last finished render pass. */
	effects: AlienEffects | null;
	/** Effects added in the current render pass. */
	newEffects: AlienEffects | null;
	/** Values memoized in the last finished render pass. */
	memos: Map<any, any> | null;
	/** Values memoized in the current render pass. */
	newMemos: Map<any, any> | null;
	constructor(tag: (props: Props) => JSX.ChildrenProp, initialProps: Props);
	get firstChild(): ChildNode | null;
	get lastChild(): ChildNode | null;
	get ownerDocument(): Document | null | undefined;
	patchProps(newProps: Partial<Props>): void;
	replaceProps(newProps: Props): void;
	truncate(length: number): void;
	setRootNode(rootNode: ChildNode | DocumentFragment): void;
	getNodeForKey(key: JSX.ElementKey): ChildNode | DocumentFragment | undefined;
	setNodeForKey(key: JSX.ElementKey, node: ChildNode | DocumentFragment): void;
	getNodeUpdateForKey(key: JSX.ElementKey): AnyDeferredNode | undefined;
	setNodeUpdateForKey(key: JSX.ElementKey, update: AnyDeferredNode): void;
	nextCompute(): void;
	isObservablyPure(): boolean;
	didObserve(ref: ReadonlyRef): void;
	/**
	 * Note: This doesn't remove the root node from its document.
	 */
	dispose(): void;
}
interface AlienComponent {
	readonly name: string;
}
/**
 * Any JSX element created outside of a component must be removed from the DOM
 * with this function if you don't plan to reuse it. If you only want to reuse
 * some or all of its descendants, be sure to remove those descendants (with
 * `node.remove()` not this method) before calling this.
 */
export declare function unmount(node: ChildNode | DocumentFragment | null | undefined, skipRemove?: boolean, keepComponent?: AlienComponent | null): void;
export interface ArrayViewProps<T> {
	array: ArrayRef<T>;
	children: ArrayViewRenderFn<T>;
	/**
	 * By default, the array items are re-rendered only if the `children` function
	 * is changed. For explicit control of the re-rendering, you can provide a
	 * `deps` array.
	 */
	deps?: readonly any[];
}
export declare function ArrayView<T>({ array, children: render, deps, }: ArrayViewProps<T>): HTMLElement | null;
export declare function Fragment(props: {
	children: JSX.ChildrenProp;
}): JSX.Element;
export declare function createFragment(children: JSX.ChildrenProp): DocumentFragment | DeferredCompositeNode;
export interface ShadowRootProps extends ShadowRootInit {
	children: JSX.ChildrenProp;
}
declare function ShadowRoot$1(props: ShadowRootProps): JSX.Element;
export type TransitionData<Id> = {
	id: Id;
	element: JSX.Element;
	relatedId: Id | undefined;
};
export type TransitionDependency = PromiseLike<any> & {
	stop(): void;
};
export type TransitionAnimation = SpringAnimation<JSX.Element> | SpringAnimation<JSX.Element>[] | TransitionDependency;
export type TransitionProp<Id, Data = {}> = ((data: TransitionData<Id> & Data) => TransitionAnimation | Falsy) | TransitionAnimation | Falsy;
export type TransitionProps<Id> = {
	/** The unique identifier for the current entered element. */
	id: Id;
	beforeEnter?: (data: TransitionData<Id> & {
		initial: boolean;
	}) => Promisable<any>;
	initial?: AnimatedProps<JSX.Element> | boolean;
	enter?: TransitionProp<Id, {
		initial: boolean;
	}>;
	leave?: TransitionProp<Id>;
	leaveClass?: JSX.HTMLClassProp;
	/** The element to be animated can be selected from the direct child. */
	selector?: string;
	children: JSX.ChildrenProp;
};
export declare function Transition<Id>(props: TransitionProps<Id>): HTMLElement;
export declare const attachRef: (props: object, key: keyof any, ref: ReadonlyRef, didSet?: ((key: keyof any, newValue: any, oldValue: any) => void) | undefined) => void;
/**
 * Mutates an object so its enumerable properties are observable.
 */
export declare const attachRefs: <Props extends object>(object: Props, didSet?: ((key: keyof Props, newValue: any, oldValue: any) => void) | undefined) => Props;
/**
 * This is slightly unintuitive, but this function returns true unless
 * `deps` and `prevDeps` are **different arrays with the same
 * contents.** So passing the same exact array (`===` to itself) as both
 * `deps` and `prevDeps` will give you true (unintuitively).
 */
export declare function depsHaveChanged(deps: readonly any[], prevDeps: readonly any[] | undefined): boolean;
export declare function editClassList(ref: Ref<JSX.HTMLClassProp>, editor: (classList: DOMTokenList) => void): void;
/**
 * If no element key was explicitly defined by user code and the compiler
 * couldn't assign a statically defined key, then the element's JSX position is
 * used, which might also be undefined if the element was added to the DOM
 * through a native DOM API.
 */
export declare function getElementIdentity(element: object): JSX.ElementKey | undefined;
export declare function mount(root: HTMLElement, element: JSX.Element): void;
/**
 * Like `observe` but with a `target` argument that can be retargeted later.
 */
export declare const observeAs: <T extends void | object>(target: T, action: (target: T) => void) => Disposable$1<AlienBoundEffect<T, [
	action: (target: T) => void
], boolean>>;
export interface ComponentNode<Props extends object = any> {
	get tag(): FunctionComponent<Props>;
	get props(): Readonly<Props>;
	get rootNode(): ChildNode | DocumentFragment;
	get firstChild(): ChildNode;
	get firstElementChild(): JSX.Element | null;
	get lastChild(): ChildNode;
	get lastElementChild(): JSX.Element | null;
	get childNodes(): readonly ChildNode[];
	get ownerDocument(): Document | null;
	/**
	 * Update the value of the given props. It's a partial update, so any props
	 * not defined in `newProps` are left unchanged. Any object props are replaced
	 * by any new object, rather than being merged.
	 */
	patchProps(newProps: Partial<Props>): void;
	/**
	 * Same as `updateProps`, but any props which are not defined in `newProps`
	 * are set to undefined.
	 */
	replaceProps(newProps: Props): void;
}
/**
 * Similar to rendering a component with JSX, but you get a `ComponentNode`
 * back, which keeps a reference to the root node of the component instance,
 * even if it gets replaced.
 */
export declare function renderComponent<Props extends object = {}>(tag: FunctionComponent<Props>, initialProps?: Props): ComponentNode<Props>;
/**
 * Restore a previous HTML element within a component's node references, so a
 * JSX element using the same key will be reuse the DOM node instead of
 * generating a new one.
 *
 * This function is meant to support JSX updates of DOM nodes that are removed
 * from or moved within the DOM tree, and then subsequently re-added to it.
 */
export declare function restoreNodeReferences(node: ChildNode | DocumentFragment): void;
export declare function toElements<Element extends HTMLOrSVGElement$1>(node: Exclude<JSX.ElementLike, AlienNode | ChildrenFragment>): Element[];
export declare function isNode(val: any): val is Node | ChildNode | ParentNode;
export declare function isElement(node: Node): node is HTMLOrSVGElement$1;
export declare function isFragment(node: Node): node is DocumentFragment;
export declare function isTextNode(node: Node): node is Text;
export declare function isComment(node: Node): node is Comment;
export declare function isDocument(node: Node): node is Document;
/**
 * ⚠️ This returns true for functions due to the possibility of element
 * thunking.
 */
export declare function isJSXChild(value: any): value is JSX.Element | DocumentFragment | Comment;
/**
 * Channels are strongly typed event buses.
 *
 * When an element is passed as the first argument, the channel will only send
 * messages to receivers that are bound to that element or to one of its
 * ancestors.
 *
 * The `Data` type must be a plain object. Use the `{}` type to represent a
 * message with no custom metadata.
 */
export type Channel<Data extends object = Record<string, any>, Target extends object | void = any> = Channel.Signature<Data, Target> & Channel.FunctionTuple<Data, Target>;
export declare namespace Channel {
	interface Message<T extends Signature = Signature, Target extends InferTarget<T> = InferTarget<T>> {
		readonly target?: Target;
		currentTarget?: InferTarget<T>;
		stopPropagation(): void;
		stopImmediatePropagation(): void;
	}
	/**
	 * A message that is sent to the target and its ancestors. This propagation
	 * can be interrupted by `stopPropagation` or `stopImmediatePropagation`.
	 */
	interface BubblingMessage<T extends Signature = Signature, Target extends InferTarget<T> = InferTarget<T>> extends Message<T, Target> {
		readonly target: Target;
		currentTarget: InferTarget<T>;
	}
	/** A receiver is a function that receives messages from a channel. */
	type Receiver<T extends Signature = Signature, Target extends InferTarget<T> = InferTarget<T>> = (message: (InferTarget<T> extends void ? Message<T, Target> : BubblingMessage<T, Target>) & InferData<T>) => boolean | void;
	/** The signature of a channel. */
	interface Signature<Data extends object = Record<string, any>, Target extends object | void = any> extends Send<Signature<Data, Target>>, Connect<Signature<Data, Target>> {
	}
	/**
	 * Every channel returned by `defineChannel` can be divided into two functions
	 * (`send` and `connect`) via array destructuring.
	 */
	type FunctionTuple<Data extends object = Record<string, any>, Target extends object | void = any> = [
		send: Send<Signature<Data, Target>>,
		connect: Connect<Signature<Data, Target>>
	];
	/** The function that sends a message to a channel. */
	type Send<T extends Signature = Signature> = {
		<Target extends InferTarget<T>>(target: Target, message: VoidIfEmpty<InferData<T>>): boolean;
		(message: VoidIfEmpty<InferData<T>>): boolean;
	};
	/** The function that connects a receiver to a channel. */
	type Connect<T extends Signature = Signature> = {
		<Target extends InferTarget<T>>(target: Target, receiver: Receiver<T>): Connection<Target>;
		(receiver: Receiver<Signature<InferData<T>, void>>): Connection<void>;
	};
	/** A disposable connection of a receiver to a channel. */
	type Connection<Target extends object | void> = Disposable$1<AlienBoundEffect<Target>>;
}
type InferData<T extends Channel.Signature> = T extends Channel.Signature<infer Data> ? Data : never;
type InferTarget<T extends Channel.Signature> = T extends Channel.Signature<any, infer Target> ? Target : never;
type VoidIfEmpty<Data extends object> = Data extends any ? ({} extends Data ? void : never) | ({} extends Required<Data> ? never : Data) : never;
/**
 * Channels are strongly typed event buses.
 *
 * When an element is passed as the first argument, the channel will only send
 * messages to receivers that are bound to that element or to one of its
 * ancestors.
 *
 * The `Data` type must be a plain object. Use the `{}` type to represent a
 * message with no custom metadata.
 */
export declare function defineChannel<Data extends object = {}, Target extends object = Node>({ isTarget, bubblingKey, }?: {
	isTarget?(node: any): node is Target;
	bubblingKey?: Extract<keyof Target, string> | false;
}): Channel<Data, Target>;
type Fn = (...args: any[]) => any;
type FnPropertyOf<T extends object> = {
	[K in keyof T]: T[K] extends Fn ? K : never;
}[keyof T];
export declare class Controller<State extends object = any, Key = any> {
	protected singleton: boolean;
	protected instances: Map<any, any> | undefined;
	constructor(singleton?: boolean);
	exists(key: Key): boolean;
	/**
	 * Set the entire state of an instance. Any properties not provided will be
	 * set to `undefined`.
	 */
	set(arg1: [
		Key
	] extends [
		void
	] ? State : Key, arg2: [
		Key
	] extends [
		void
	] ? void : State): void;
	/**
	 * Patch the state of an instance. Any properties not provided will be left
	 * unchanged.
	 */
	patch(arg1: [
		Key
	] extends [
		void
	] ? Partial<State> : Key, arg2: [
		Key
	] extends [
		void
	] ? void : Partial<State>): void;
	protected call<P extends FnPropertyOf<State>>(key: Key, method: P, ...args: Parameters<Extract<State[P], Fn>>): ReturnType<Extract<State[P], Fn>>;
}
export type ControllerProxy<State extends object, Key> = unknown & Controller<State, Key> & {
	[P in FnPropertyOf<State>]-?: (...args: Parameters<Extract<State[P], Fn>>) => ReturnType<Extract<State[P], Fn>>;
};
export declare function defineController<State extends object>(singleton: true): ControllerProxy<State, void>;
export declare function defineController<Key, State extends object>(singleton?: false): ControllerProxy<State, Key>;
/**
 * Only one component can use a controller instance at a time. The `init`
 * function should declare every possible property, even if the initial value is
 * `undefined`. Every property in the returned object is observable.
 */
export declare function useController<State extends object, Params extends any[]>(ctrl: Controller<State, void>, init: new (...params: Params) => State, ...params: Params): Refs<State>;
export declare function useController<Key, State extends object, Params extends any[]>(ctrl: Controller<State, Key>, key: Key, init: new (...params: Params) => State, ...params: Params): Refs<State>;
export declare function useController<State extends object, Params extends any[]>(ctrl: Controller<State, void>, init: (...params: Params) => State, ...params: Params): Refs<State>;
export declare function useController<Key, State extends object, Params extends any[]>(ctrl: Controller<State, Key>, key: Key, init: (...params: Params) => State, ...params: Params): Refs<State>;
type NodeCallback = (node: ChildNode) => void;
export declare function matchDescendants<E extends Element>(target: Node, selector: string, effect: (node: E) => void): Disposable$1<AlienBoundEffect<Node, [
	callback: NodeCallback
], boolean>>;
export declare function observeNewChildren(target: Node, listener: (childNode: ChildNode) => void): Disposable$1<AlienBoundEffect<Node, [
	callback: NodeCallback
], boolean>>;
export declare function observeRemovedChildren(target: Node, listener: (childNode: ChildNode) => void): Disposable$1<AlienBoundEffect<Node, [
	callback: NodeCallback
], boolean>>;
export declare const observeNewDescendants: AlienEffectType<[
	target: Node,
	callback: NodeCallback
]>;
export declare const observeRemovedDescendants: AlienEffectType<[
	target: Node,
	callback: NodeCallback
]>;
/**
 * Runs the effect when the given target is mounted, then stops
 * observing the document.
 */
export declare const onMount: (target: ChildNode, effect: () => void, rootNode?: Node) => Disposable$1<AlienBoundEffect<ChildNode, [
	key: "onAdded" | "onRemoved",
	effect: () => void,
	rootNode: Node
], boolean>>;
/**
 * Runs the effect when the given target is unmounted, then stops
 * observing the document.
 */
export declare const onUnmount: (target: ChildNode, effect: () => void, rootNode?: Node) => Disposable$1<AlienBoundEffect<ChildNode, [
	key: "onAdded" | "onRemoved",
	effect: () => void,
	rootNode: Node
], boolean>>;
export declare function patchAttributes<T extends HTMLOrSVGElement$1>(context: T, attributes: JSX.InferAttributes<T>): void;
export declare function hasClass(context: HTMLElement | SVGSVGElement, className: string): boolean;
export declare function addClass(context: HTMLElement | SVGSVGElement, classes: string | string[]): void;
export declare function removeClass(context: HTMLElement | SVGSVGElement, classes: string | string[]): void;
export declare function removeMatchingClass(context: HTMLElement | SVGSVGElement, pattern: RegExp | ((name: string) => boolean | void)): void;
export declare function toggleClass(context: HTMLElement | SVGSVGElement, classes: string | string[], force?: boolean | ((name: string) => boolean)): void;
/**
 * If `classList` was an array, this would be like calling `classList.every()`.
 */
export declare function hasEveryClass(context: HTMLElement | SVGSVGElement, classes: string | string[]): boolean;
/**
 * If `classList` was an array, this would be like calling `classList.some()`.
 */
export declare function hasSomeClass(context: HTMLElement | SVGSVGElement, classes: string | string[]): boolean;
/**
 * Iterate every class name in the element's `classList`. Return the first class
 * name that matches the pattern. If `pattern` is a function, any string result
 * (even an empty one) will be returned.
 */
export declare function matchClass(context: HTMLElement | SVGSVGElement, pattern: RegExp | ((name: string) => string | false | null | undefined)): string;
export declare function lastChildWhere<T extends ChildNode = ChildNode>(parentNode: ParentNode, filter: (child: T) => boolean): T | null;
export declare function lastElementChildWhere<T extends SVGElement = SVGElement>(parentNode: SVGElement, filter: (child: T) => boolean): T | null;
export declare function lastElementChildWhere<T extends AnyElement = HTMLOrSVGElement$1>(parentNode: AnyElement, filter: (child: T) => boolean): T | null;
type AlienTag$1 = AnyElement | keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap;
type AlienSelect$1<T extends AlienTag$1> = T extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[T] : T extends keyof SVGElementTagNameMap ? SVGElementTagNameMap[T] : T;
/** Either a CSS selector or a function that returns a boolean */
export type AlienNodeFilter<Node> = string | ((node: Node) => boolean);
/**
 * Of the given nodes, return the ones that match the given selector.
 */
export declare function nodeFilter<T extends Node>(nodes: NodeListOf<T> | readonly T[], filter: AlienNodeFilter<T>): T[];
export declare function nodeFilter<T extends Node>(node: T, filter: AlienNodeFilter<T>): T | null;
export declare function nodeFilter<T extends Node, Nodes extends T | NodeListOf<T> | readonly T[]>(nodes: Nodes, filter: AlienNodeFilter<T>): Nodes;
export declare function parents<Node extends ParentNode>(node: ChildNode): Generator<Node, void, unknown>;
export declare function firstParent<Node extends ParentNode>(node: ChildNode, filter: AlienNodeFilter<Node>): ParentNode | null;
export declare function removeChildren(context: ParentNode, selector?: AlienNodeFilter<ChildNode>): void;
export declare enum SiblingPosition {
	/** Start from the first sibling. Visit all siblings. */
	any = 0,
	/** Start from the last sibling. Visit all siblings. */
	anyReverse = 1,
	/** Start from the first sibling before the context. Stop at context. */
	before = 2,
	/** Start from the last sibling before the context. Stop at context. */
	beforeReverse = 3,
	/** Start from the first sibling after the context. Stop at context.  */
	after = 4,
	/** Start from the last sibling after the context. Stop at context. */
	afterReverse = 5
}
export type SiblingPositionKey = keyof typeof SiblingPosition;
export declare function firstSibling<T extends AlienTag$1 = HTMLOrSVGElement$1>(context: JSX.Element, selector: AlienNodeFilter<JSX.Element | Comment | Text>): AlienSelect$1<T> | undefined;
export declare function firstSibling<T extends AlienTag$1 = HTMLOrSVGElement$1>(context: Element, selector: AlienNodeFilter<Element | Comment | Text>): AlienSelect$1<T> | undefined;
export declare function firstSibling<T extends AlienTag$1 = HTMLOrSVGElement$1>(context: JSX.Element, position: SiblingPosition | SiblingPositionKey, selector: AlienNodeFilter<JSX.Element | Comment | Text>): AlienSelect$1<T> | undefined;
export declare function firstSibling<T extends AlienTag$1 = HTMLOrSVGElement$1>(context: Element, position: SiblingPosition | SiblingPositionKey, selector: AlienNodeFilter<Element | Comment | Text>): AlienSelect$1<T> | undefined;
export declare function siblings<T extends AlienTag$1>(context: JSX.Element, selector?: AlienNodeFilter<JSX.Element | Comment | Text>): Generator<AlienSelect$1<T>>;
export declare function siblings<T extends AlienTag$1>(context: Element, selector?: AlienNodeFilter<Element | Comment | Text>): Generator<AlienSelect$1<T>>;
export declare function siblings<T extends AlienTag$1>(context: JSX.Element, position: SiblingPosition | SiblingPositionKey, selector?: AlienNodeFilter<JSX.Element | Comment | Text>): Generator<AlienSelect$1<T>>;
export declare function siblings<T extends AlienTag$1>(context: Element, position: SiblingPosition | SiblingPositionKey, selector?: AlienNodeFilter<Element | Comment | Text>): Generator<AlienSelect$1<T>>;
export declare function siblings<T extends AlienTag$1>(context: JSX.Element, position: SiblingPosition | SiblingPositionKey | AlienNodeFilter<JSX.Element | Comment | Text>, selector?: AlienNodeFilter<JSX.Element | Comment | Text>): Generator<AlienSelect$1<T>>;
export declare function siblings<T extends AlienTag$1>(context: Element, position?: SiblingPosition | SiblingPositionKey | AlienNodeFilter<Element | Comment | Text>, selector?: AlienNodeFilter<Element | Comment | Text>): Generator<AlienSelect$1<T>>;
/**
 * Merge the given style object into the element's `style` attribute. If a style
 * property is being animated, the animation is interrupted. Any value accepted
 * by JSX is also accepted here.
 */
export declare const patchStyle: (context: HTMLElement | SVGSVGElement, style: CSSAttributes) => void;
/**
 * The `Howl` class allows you to play sound files. It supports `.ogg` and
 * `.aac` file formats only, which is all you'll need for modern browser
 * support. Many of its properties are all observable.
 */
export declare class Howl<Sprite extends string | null = any> implements PromiseLike<void> {
	readonly src: URL[];
	readonly sprite: Record<Extract<Sprite, string>, number[]> | undefined;
	readonly spriteKey: Extract<Sprite, string> | null;
	readonly statusRef: Ref<Howl.Status>;
	readonly maxVolumeRef: Ref<number>;
	readonly mutedRef: Ref<boolean> | ReadonlyRef<boolean>;
	fadeOut: (duration: number) => void;
	buffer: AudioBuffer | null;
	error: Error | null;
	loop: boolean;
	private loadObserver;
	private disconnect;
	static get muted(): boolean;
	static set muted(value: boolean);
	static get volume(): number;
	static set volume(value: number);
	constructor(options: Howl.Options<Sprite>);
	/**
	 * Play a sound. Resuming after a `stop` call is not yet supported.
	 */
	play(options?: Howl.PlayOptions): Howl<Sprite>;
	/**
	 * Create a sprite instance and play it.
	 */
	play<SpriteKey extends Extract<keyof Sprite, string>>(spriteKey: SpriteKey, options?: Howl.PlayOptions): Howl<SpriteKey>;
	stop(): void;
	/**
	 * Wait for the sound to be either loaded or errored. If the sound is playing,
	 * the promise will resolve when playing is either stopped or finished.
	 */
	then<TResult1 = void, TResult2 = never>(onFulfilled?: (value: void) => TResult1 | PromiseLike<TResult1>, onRejected?: (error: any) => TResult2 | PromiseLike<TResult2>): Promise<TResult1 | TResult2>;
	private load;
	private connect;
}
export interface Howl {
	/** @observable */
	status: Howl.Status;
	/** @observable */
	maxVolume: number;
	/**
	 * For sprites, the `muted` property is shared between all instances of the
	 * same sound file.
	 * @observable
	 */
	muted: boolean;
}
export declare namespace Howl {
	type Status = "loading" | "loaded" | "playing" | "stopping" | "error";
	interface Options<Sprite extends string | null = any> {
		src: string | string[];
		/**
		 * Sprites are a way to play a specific part of an audio file. The object
		 * keys are the names, and the values are arrays with start and end times.
		 * Typically, you would generate a JSON file (with a tool like Audiosprite)
		 * for your application to import.
		 */
		sprite?: Record<Extract<Sprite, string>, number[]>;
		/**
		 * Set the default value for the `loop` option when `play` is called.
		 * @default false
		 */
		loop?: boolean;
		/** @default 1 */
		maxVolume?: number;
		/** @default false */
		muted?: boolean | ReadonlyRef<boolean>;
	}
	interface PlayOptions {
		/**
		 * The number of milliseconds for the sound to fade from silent to the
		 * `volume` option or `maxVolume` property.
		 * @default 0
		 */
		fade?: number;
		/**
		 * When true, the sound repeats once it finishes. If the user hasn't
		 * interacted with the page yet, the sound will wait for the first
		 * interaction and start playing then.
		 * @default false
		 */
		loop?: boolean;
		/**
		 * The volume the sound is played at. Note that this value is multiplied by
		 * the `maxVolume` property.
		 * @default 1
		 */
		volume?: number;
	}
}
export declare const SVGNamespace = "http://www.w3.org/2000/svg";
/** This is used by JSX SVG elements. */
export declare function createElement(tag: any, props: any, ...children: any[]): any;

export {
	AlienSelect$1 as AlienSelect,
	AlienTag$1 as AlienTag,
	Color,
	Disposable$1 as Disposable,
	ShadowRoot$1 as ShadowRoot,
	mixColor,
	parseColor,
};

export {};
